diff --git a/include/mbedtls/mbedtls_config.h b/include/mbedtls/mbedtls_config.h
index 89d565971..bb6d4ce2a 100644
--- a/include/mbedtls/mbedtls_config.h
+++ b/include/mbedtls/mbedtls_config.h
@@ -140,7 +140,7 @@
  *       regardless of the setting of MBEDTLS_HAVE_TIME, unless
  *       MBEDTLS_TIMING_ALT is used. See timing.c for more information.
  */
-#define MBEDTLS_HAVE_TIME
+//#define MBEDTLS_HAVE_TIME
 
 /**
  * \def MBEDTLS_HAVE_TIME_DATE
@@ -161,7 +161,7 @@
  * mbedtls_platform_gmtime_r() at compile-time by using the macro
  * MBEDTLS_PLATFORM_GMTIME_R_ALT.
  */
-#define MBEDTLS_HAVE_TIME_DATE
+//#define MBEDTLS_HAVE_TIME_DATE
 
 /**
  * \def MBEDTLS_PLATFORM_MEMORY
@@ -185,7 +185,7 @@
  *
  * Enable this layer to allow use of alternative memory allocators.
  */
-//#define MBEDTLS_PLATFORM_MEMORY
+#define MBEDTLS_PLATFORM_MEMORY
 
 /**
  * \def MBEDTLS_PLATFORM_NO_STD_FUNCTIONS
@@ -204,7 +204,7 @@
  * Uncomment to prevent default assignment of standard functions in the
  * platform layer.
  */
-//#define MBEDTLS_PLATFORM_NO_STD_FUNCTIONS
+#define MBEDTLS_PLATFORM_NO_STD_FUNCTIONS
 
 /**
  * \def MBEDTLS_PLATFORM_EXIT_ALT
@@ -230,12 +230,12 @@
  * platform function
  */
 //#define MBEDTLS_PLATFORM_SETBUF_ALT
-//#define MBEDTLS_PLATFORM_EXIT_ALT
+#define MBEDTLS_PLATFORM_EXIT_ALT
 //#define MBEDTLS_PLATFORM_TIME_ALT
-//#define MBEDTLS_PLATFORM_FPRINTF_ALT
-//#define MBEDTLS_PLATFORM_PRINTF_ALT
-//#define MBEDTLS_PLATFORM_SNPRINTF_ALT
-//#define MBEDTLS_PLATFORM_VSNPRINTF_ALT
+#define MBEDTLS_PLATFORM_FPRINTF_ALT
+#define MBEDTLS_PLATFORM_PRINTF_ALT
+#define MBEDTLS_PLATFORM_SNPRINTF_ALT
+#define MBEDTLS_PLATFORM_VSNPRINTF_ALT
 //#define MBEDTLS_PLATFORM_NV_SEED_ALT
 //#define MBEDTLS_PLATFORM_SETUP_TEARDOWN_ALT
 //#define MBEDTLS_PLATFORM_MS_TIME_ALT
@@ -1058,7 +1058,7 @@
  *
  * Enable functions that use the filesystem.
  */
-#define MBEDTLS_FS_IO
+//#define MBEDTLS_FS_IO
 
 /**
  * \def MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES
@@ -1081,7 +1081,7 @@
  *
  * Uncomment this macro to disable the built-in platform entropy functions.
  */
-//#define MBEDTLS_NO_PLATFORM_ENTROPY
+#define MBEDTLS_NO_PLATFORM_ENTROPY
 
 /**
  * \def MBEDTLS_ENTROPY_FORCE_SHA256
@@ -2559,7 +2559,7 @@
  *
  * This module provides a generic entropy pool
  */
-#define MBEDTLS_ENTROPY_C
+//#define MBEDTLS_ENTROPY_C
 
 /**
  * \def MBEDTLS_ERROR_C
@@ -2629,7 +2629,7 @@
  *
  * Uncomment to enable the LMS verification algorithm and public key operations.
  */
-#define MBEDTLS_LMS_C
+//#define MBEDTLS_LMS_C
 
 /**
  * \def MBEDTLS_LMS_PRIVATE
@@ -2743,7 +2743,7 @@
  *
  * This module provides networking routines.
  */
-#define MBEDTLS_NET_C
+//#define MBEDTLS_NET_C
 
 /**
  * \def MBEDTLS_OID_C
@@ -2780,7 +2780,7 @@
  *
  * This modules adds support for the VIA PadLock on x86.
  */
-#define MBEDTLS_PADLOCK_C
+//#define MBEDTLS_PADLOCK_C
 
 /**
  * \def MBEDTLS_PEM_PARSE_C
@@ -2962,7 +2962,7 @@
  *           or MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG.
  *
  */
-#define MBEDTLS_PSA_CRYPTO_C
+//#define MBEDTLS_PSA_CRYPTO_C
 
 /**
  * \def MBEDTLS_PSA_CRYPTO_SE_C
@@ -2991,7 +2991,7 @@
  *           either MBEDTLS_PSA_ITS_FILE_C or a native implementation of
  *           the PSA ITS interface
  */
-#define MBEDTLS_PSA_CRYPTO_STORAGE_C
+//#define MBEDTLS_PSA_CRYPTO_STORAGE_C
 
 /**
  * \def MBEDTLS_PSA_ITS_FILE_C
@@ -3003,7 +3003,7 @@
  *
  * Requires: MBEDTLS_FS_IO
  */
-#define MBEDTLS_PSA_ITS_FILE_C
+//#define MBEDTLS_PSA_ITS_FILE_C
 
 /**
  * \def MBEDTLS_RIPEMD160_C
@@ -3333,7 +3333,7 @@
  *
  * Module:  library/timing.c
  */
-#define MBEDTLS_TIMING_C
+//#define MBEDTLS_TIMING_C
 
 /**
  * \def MBEDTLS_VERSION_C
diff --git a/include/mbedtls/platform.h b/include/mbedtls/platform.h
index f65158719..f506feb05 100644
--- a/include/mbedtls/platform.h
+++ b/include/mbedtls/platform.h
@@ -465,6 +465,13 @@ int mbedtls_platform_setup(mbedtls_platform_context *ctx);
  */
 void mbedtls_platform_teardown(mbedtls_platform_context *ctx);
 
+int atoi(const char *nptr);
+int rand(void);
+void srand(unsigned int seed);
+int strcmp(const char *string1, const char *string2);
+char *strchr(const char *str, int c);
+char *strstr(const char *str, const char *strSearch);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/library/alignment.h b/library/alignment.h
index 41823485a..647118308 100644
--- a/library/alignment.h
+++ b/library/alignment.h
@@ -189,6 +189,7 @@ inline void mbedtls_put_unaligned_uint64(void *p, uint64_t x)
  * compiler may be able to detect and transform into the relevant bswap or
  * similar instruction.
  */
+#undef MBEDTLS_BSWAP16
 #if !defined(MBEDTLS_BSWAP16)
 static inline uint16_t mbedtls_bswap16(uint16_t x)
 {
@@ -199,6 +200,7 @@ static inline uint16_t mbedtls_bswap16(uint16_t x)
 #define MBEDTLS_BSWAP16 mbedtls_bswap16
 #endif /* !defined(MBEDTLS_BSWAP16) */
 
+#undef MBEDTLS_BSWAP32
 #if !defined(MBEDTLS_BSWAP32)
 static inline uint32_t mbedtls_bswap32(uint32_t x)
 {
@@ -211,6 +213,7 @@ static inline uint32_t mbedtls_bswap32(uint32_t x)
 #define MBEDTLS_BSWAP32 mbedtls_bswap32
 #endif /* !defined(MBEDTLS_BSWAP32) */
 
+#undef MBEDTLS_BSWAP64
 #if !defined(MBEDTLS_BSWAP64)
 static inline uint64_t mbedtls_bswap64(uint64_t x)
 {
diff --git a/library/ctr_drbg.c b/library/ctr_drbg.c
index acc4208cc..d314ede27 100644
--- a/library/ctr_drbg.c
+++ b/library/ctr_drbg.c
@@ -348,16 +348,20 @@ static int mbedtls_ctr_drbg_reseed_internal(mbedtls_ctr_drbg_context *ctx,
     size_t seedlen = 0;
     int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
 
+    mbedtls_printf("mbedtls_ctr_drbg_reseed_internal - 1\n");
     if (ctx->entropy_len > MBEDTLS_CTR_DRBG_MAX_SEED_INPUT) {
         return MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG;
     }
+    mbedtls_printf("mbedtls_ctr_drbg_reseed_internal - 2\n");
     if (nonce_len > MBEDTLS_CTR_DRBG_MAX_SEED_INPUT - ctx->entropy_len) {
         return MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG;
     }
+    mbedtls_printf("mbedtls_ctr_drbg_reseed_internal - 3\n");
     if (len > MBEDTLS_CTR_DRBG_MAX_SEED_INPUT - ctx->entropy_len - nonce_len) {
         return MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG;
     }
 
+    mbedtls_printf("mbedtls_ctr_drbg_reseed_internal - 4\n");
     memset(seed, 0, MBEDTLS_CTR_DRBG_MAX_SEED_INPUT);
 
     /* Gather entropy_len bytes of entropy to seed state. */
@@ -366,6 +370,7 @@ static int mbedtls_ctr_drbg_reseed_internal(mbedtls_ctr_drbg_context *ctx,
     }
     seedlen += ctx->entropy_len;
 
+    mbedtls_printf("mbedtls_ctr_drbg_reseed_internal - 5\n");
     /* Gather entropy for a nonce if requested. */
     if (nonce_len != 0) {
         if (0 != ctx->f_entropy(ctx->p_entropy, seed + seedlen, nonce_len)) {
@@ -374,23 +379,27 @@ static int mbedtls_ctr_drbg_reseed_internal(mbedtls_ctr_drbg_context *ctx,
         seedlen += nonce_len;
     }
 
+    mbedtls_printf("mbedtls_ctr_drbg_reseed_internal - 6\n");
     /* Add additional data if provided. */
     if (additional != NULL && len != 0) {
         memcpy(seed + seedlen, additional, len);
         seedlen += len;
     }
 
+    mbedtls_printf("mbedtls_ctr_drbg_reseed_internal - 7\n");
     /* Reduce to 384 bits. */
     if ((ret = block_cipher_df(seed, seed, seedlen)) != 0) {
         goto exit;
     }
 
+    mbedtls_printf("mbedtls_ctr_drbg_reseed_internal - 8\n");
     /* Update state. */
     if ((ret = ctr_drbg_update_internal(ctx, seed)) != 0) {
         goto exit;
     }
     ctx->reseed_counter = 1;
 
+    mbedtls_printf("mbedtls_ctr_drbg_reseed_internal - 9\n");
 exit:
     mbedtls_platform_zeroize(seed, sizeof(seed));
     return ret;
@@ -458,17 +467,20 @@ int mbedtls_ctr_drbg_seed(mbedtls_ctr_drbg_context *ctx,
                  (size_t) ctx->reseed_counter :
                  good_nonce_len(ctx->entropy_len));
 
+    mbedtls_printf("mbedtls_ctr_drbg_seed - 1\n");
     /* Initialize with an empty key. */
     if ((ret = mbedtls_aes_setkey_enc(&ctx->aes_ctx, key,
                                       MBEDTLS_CTR_DRBG_KEYBITS)) != 0) {
         return ret;
     }
 
+    mbedtls_printf("mbedtls_ctr_drbg_seed - 2\n");
     /* Do the initial seeding. */
     if ((ret = mbedtls_ctr_drbg_reseed_internal(ctx, custom, len,
                                                 nonce_len)) != 0) {
         return ret;
     }
+    mbedtls_printf("mbedtls_ctr_drbg_seed - 3\n");
     return 0;
 }
 
diff --git a/library/entropy.c b/library/entropy.c
index 00079176a..b72231a17 100644
--- a/library/entropy.c
+++ b/library/entropy.c
@@ -211,10 +211,12 @@ static int entropy_gather_internal(mbedtls_entropy_context *ctx)
     unsigned char buf[MBEDTLS_ENTROPY_MAX_GATHER];
     size_t olen;
 
+    mbedtls_printf("entropy_gather_internal - 1\n");
     if (ctx->source_count == 0) {
         return MBEDTLS_ERR_ENTROPY_NO_SOURCES_DEFINED;
     }
 
+    mbedtls_printf("entropy_gather_internal - 2\n");
     /*
      * Run through our entropy sources
      */
@@ -229,6 +231,7 @@ static int entropy_gather_internal(mbedtls_entropy_context *ctx)
             goto cleanup;
         }
 
+        mbedtls_printf("entropy_gather_internal - 3\n");
         /*
          * Add if we actually gathered something
          */
@@ -239,12 +242,15 @@ static int entropy_gather_internal(mbedtls_entropy_context *ctx)
             }
             ctx->source[i].size += olen;
         }
+        mbedtls_printf("entropy_gather_internal - 4\n");
     }
 
+    mbedtls_printf("entropy_gather_internal - 5\n");
     if (have_one_strong == 0) {
         ret = MBEDTLS_ERR_ENTROPY_NO_STRONG_SOURCE;
     }
 
+    mbedtls_printf("entropy_gather_internal - 6\n");
 cleanup:
     mbedtls_platform_zeroize(buf, sizeof(buf));
 
@@ -282,6 +288,7 @@ int mbedtls_entropy_func(void *data, unsigned char *output, size_t len)
     mbedtls_entropy_context *ctx = (mbedtls_entropy_context *) data;
     unsigned char buf[MBEDTLS_ENTROPY_BLOCK_SIZE];
 
+    mbedtls_printf("mbedtls_entropy_func - 1\n");
     if (len > MBEDTLS_ENTROPY_BLOCK_SIZE) {
         return MBEDTLS_ERR_ENTROPY_SOURCE_FAILED;
     }
@@ -304,6 +311,7 @@ int mbedtls_entropy_func(void *data, unsigned char *output, size_t len)
     }
 #endif
 
+    mbedtls_printf("mbedtls_entropy_func - 2\n");
     /*
      * Always gather extra entropy before a call
      */
@@ -313,10 +321,12 @@ int mbedtls_entropy_func(void *data, unsigned char *output, size_t len)
             goto exit;
         }
 
+        mbedtls_printf("mbedtls_entropy_func - 3\n");
         if ((ret = entropy_gather_internal(ctx)) != 0) {
             goto exit;
         }
 
+        mbedtls_printf("mbedtls_entropy_func - 4\n");
         thresholds_reached = 1;
         strong_size = 0;
         for (i = 0; i < ctx->source_count; i++) {
@@ -331,6 +341,7 @@ int mbedtls_entropy_func(void *data, unsigned char *output, size_t len)
 
     memset(buf, 0, MBEDTLS_ENTROPY_BLOCK_SIZE);
 
+    mbedtls_printf("mbedtls_entropy_func - 5\n");
     /*
      * Note that at this stage it is assumed that the accumulator was started
      * in a previous call to entropy_update(). If this is not guaranteed, the
@@ -340,6 +351,7 @@ int mbedtls_entropy_func(void *data, unsigned char *output, size_t len)
         goto exit;
     }
 
+    mbedtls_printf("mbedtls_entropy_func - 6\n");
     /*
      * Reset accumulator and counters and recycle existing entropy
      */
@@ -350,15 +362,18 @@ int mbedtls_entropy_func(void *data, unsigned char *output, size_t len)
     if (ret != 0) {
         goto exit;
     }
+    mbedtls_printf("mbedtls_entropy_func - 7\n");
     ret = mbedtls_md_starts(&ctx->accumulator);
     if (ret != 0) {
         goto exit;
     }
+    mbedtls_printf("mbedtls_entropy_func - 8\n");
     if ((ret = mbedtls_md_update(&ctx->accumulator, buf,
                                  MBEDTLS_ENTROPY_BLOCK_SIZE)) != 0) {
         goto exit;
     }
 
+    mbedtls_printf("mbedtls_entropy_func - 9\n");
     /*
      * Perform second hashing on entropy
      */
@@ -367,6 +382,7 @@ int mbedtls_entropy_func(void *data, unsigned char *output, size_t len)
         goto exit;
     }
 
+    mbedtls_printf("mbedtls_entropy_func - 10\n");
     for (i = 0; i < ctx->source_count; i++) {
         ctx->source[i].size = 0;
     }
@@ -384,6 +400,7 @@ exit:
     }
 #endif
 
+    mbedtls_printf("mbedtls_entropy_func - 11\n");
     return ret;
 }
 
diff --git a/library/platform.c b/library/platform.c
index b15b7b29a..0206be4ff 100644
--- a/library/platform.c
+++ b/library/platform.c
@@ -411,4 +411,82 @@ void mbedtls_platform_teardown(mbedtls_platform_context *ctx)
 }
 #endif /* MBEDTLS_PLATFORM_SETUP_TEARDOWN_ALT */
 
+int atoi(const char *nptr)
+{
+    int val = 0;
+    int i = 0;
+    while(nptr[i]!='\0'){
+        if(nptr[i]<'0'||nptr[i]>'9')
+            return 0;
+        val *= 10;
+        val += (int) nptr[i] - 48;
+        i++;
+    }
+    return val;
+}
+
+static unsigned long int next = 1;
+
+int rand(void)
+{  
+    // RAND_MAX assumed to be 32767
+    next = next * 1103515245 + 12345;
+    return (unsigned int)(next/65536) % 32768;
+}
+
+void srand(unsigned int seed)
+{
+    next = seed;
+}
+
+int strcmp(const char *string1, const char *string2)
+{
+    while(*string1 && (*string1 == *string2))
+    {
+        string1++;
+        string2++;
+    }
+    return *(const unsigned char*)string1 - *(const unsigned char*)string2;
+}
+
+char *strchr(const char *str, int c)
+{
+    char ch;
+
+    ch = c;
+    for (;; ++str) {
+        if (*str == ch)
+            return ((char *)str);
+        if (*str == '\0')
+            return (NULL);
+    }
+    /* NOTREACHED */
+}
+
+char *strstr(const char *str, const char *strSearch)
+{
+    char *a, *b;
+
+    b = (char*) strSearch;
+    if (*b == 0) {
+	    return (char*) str;
+    }
+    for ( ; *str != 0; str += 1) {
+        if (*str != *b) {
+            continue;
+        }
+        a = (char*) str;
+        while (1) {
+            if (*b == 0) {
+                return (char*) str;
+            }
+            if (*a++ != *b++) {
+                break;
+            }
+        }
+        b = (char*) strSearch;
+    }
+    return NULL;
+}
+
 #endif /* MBEDTLS_PLATFORM_C */
diff --git a/library/platform_util.c b/library/platform_util.c
index e903f8ed3..4f5e5252f 100644
--- a/library/platform_util.c
+++ b/library/platform_util.c
@@ -51,9 +51,9 @@
 
 // Detect platforms known to support explicit_bzero()
 #if defined(__GLIBC__) && (__GLIBC__ >= 2) && (__GLIBC_MINOR__ >= 25)
-#define MBEDTLS_PLATFORM_HAS_EXPLICIT_BZERO 1
+//#define MBEDTLS_PLATFORM_HAS_EXPLICIT_BZERO 1
 #elif (defined(__FreeBSD__) && (__FreeBSD_version >= 1100037)) || defined(__OpenBSD__)
-#define MBEDTLS_PLATFORM_HAS_EXPLICIT_BZERO 1
+//#define MBEDTLS_PLATFORM_HAS_EXPLICIT_BZERO 1
 #endif
 
 #if !defined(MBEDTLS_PLATFORM_ZEROIZE_ALT)
diff --git a/programs/test/udp_proxy.c b/programs/test/udp_proxy.c
index ac527f257..4d631fe04 100644
--- a/programs/test/udp_proxy.c
+++ b/programs/test/udp_proxy.c
@@ -258,7 +258,7 @@ static void get_options(int argc, char *argv[])
             buf = mbedtls_calloc(1, len + 1);
             if (buf == NULL) {
                 mbedtls_printf(" Allocation failure\n");
-                exit(1);
+                mbedtls_exit(1);
             }
             memcpy(buf, q, len + 1);
 
