diff --git a/include/mbedtls/mbedtls_config.h b/include/mbedtls/mbedtls_config.h
index 89d565971..fc1788539 100644
--- a/include/mbedtls/mbedtls_config.h
+++ b/include/mbedtls/mbedtls_config.h
@@ -140,7 +140,7 @@
  *       regardless of the setting of MBEDTLS_HAVE_TIME, unless
  *       MBEDTLS_TIMING_ALT is used. See timing.c for more information.
  */
-#define MBEDTLS_HAVE_TIME
+//#define MBEDTLS_HAVE_TIME
 
 /**
  * \def MBEDTLS_HAVE_TIME_DATE
@@ -161,7 +161,7 @@
  * mbedtls_platform_gmtime_r() at compile-time by using the macro
  * MBEDTLS_PLATFORM_GMTIME_R_ALT.
  */
-#define MBEDTLS_HAVE_TIME_DATE
+//#define MBEDTLS_HAVE_TIME_DATE
 
 /**
  * \def MBEDTLS_PLATFORM_MEMORY
@@ -185,7 +185,7 @@
  *
  * Enable this layer to allow use of alternative memory allocators.
  */
-//#define MBEDTLS_PLATFORM_MEMORY
+#define MBEDTLS_PLATFORM_MEMORY
 
 /**
  * \def MBEDTLS_PLATFORM_NO_STD_FUNCTIONS
@@ -204,7 +204,7 @@
  * Uncomment to prevent default assignment of standard functions in the
  * platform layer.
  */
-//#define MBEDTLS_PLATFORM_NO_STD_FUNCTIONS
+#define MBEDTLS_PLATFORM_NO_STD_FUNCTIONS
 
 /**
  * \def MBEDTLS_PLATFORM_EXIT_ALT
@@ -230,12 +230,12 @@
  * platform function
  */
 //#define MBEDTLS_PLATFORM_SETBUF_ALT
-//#define MBEDTLS_PLATFORM_EXIT_ALT
+#define MBEDTLS_PLATFORM_EXIT_ALT
 //#define MBEDTLS_PLATFORM_TIME_ALT
-//#define MBEDTLS_PLATFORM_FPRINTF_ALT
-//#define MBEDTLS_PLATFORM_PRINTF_ALT
-//#define MBEDTLS_PLATFORM_SNPRINTF_ALT
-//#define MBEDTLS_PLATFORM_VSNPRINTF_ALT
+#define MBEDTLS_PLATFORM_FPRINTF_ALT
+#define MBEDTLS_PLATFORM_PRINTF_ALT
+#define MBEDTLS_PLATFORM_SNPRINTF_ALT
+#define MBEDTLS_PLATFORM_VSNPRINTF_ALT
 //#define MBEDTLS_PLATFORM_NV_SEED_ALT
 //#define MBEDTLS_PLATFORM_SETUP_TEARDOWN_ALT
 //#define MBEDTLS_PLATFORM_MS_TIME_ALT
@@ -1058,7 +1058,7 @@
  *
  * Enable functions that use the filesystem.
  */
-#define MBEDTLS_FS_IO
+//#define MBEDTLS_FS_IO
 
 /**
  * \def MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES
@@ -1081,7 +1081,7 @@
  *
  * Uncomment this macro to disable the built-in platform entropy functions.
  */
-//#define MBEDTLS_NO_PLATFORM_ENTROPY
+#define MBEDTLS_NO_PLATFORM_ENTROPY
 
 /**
  * \def MBEDTLS_ENTROPY_FORCE_SHA256
@@ -2559,7 +2559,7 @@
  *
  * This module provides a generic entropy pool
  */
-#define MBEDTLS_ENTROPY_C
+//#define MBEDTLS_ENTROPY_C
 
 /**
  * \def MBEDTLS_ERROR_C
@@ -2629,7 +2629,7 @@
  *
  * Uncomment to enable the LMS verification algorithm and public key operations.
  */
-#define MBEDTLS_LMS_C
+//#define MBEDTLS_LMS_C
 
 /**
  * \def MBEDTLS_LMS_PRIVATE
@@ -2743,7 +2743,7 @@
  *
  * This module provides networking routines.
  */
-#define MBEDTLS_NET_C
+//#define MBEDTLS_NET_C
 
 /**
  * \def MBEDTLS_OID_C
@@ -2780,7 +2780,7 @@
  *
  * This modules adds support for the VIA PadLock on x86.
  */
-#define MBEDTLS_PADLOCK_C
+//#define MBEDTLS_PADLOCK_C
 
 /**
  * \def MBEDTLS_PEM_PARSE_C
@@ -2962,7 +2962,7 @@
  *           or MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG.
  *
  */
-#define MBEDTLS_PSA_CRYPTO_C
+//#define MBEDTLS_PSA_CRYPTO_C
 
 /**
  * \def MBEDTLS_PSA_CRYPTO_SE_C
@@ -2991,7 +2991,7 @@
  *           either MBEDTLS_PSA_ITS_FILE_C or a native implementation of
  *           the PSA ITS interface
  */
-#define MBEDTLS_PSA_CRYPTO_STORAGE_C
+//#define MBEDTLS_PSA_CRYPTO_STORAGE_C
 
 /**
  * \def MBEDTLS_PSA_ITS_FILE_C
@@ -3003,7 +3003,7 @@
  *
  * Requires: MBEDTLS_FS_IO
  */
-#define MBEDTLS_PSA_ITS_FILE_C
+//#define MBEDTLS_PSA_ITS_FILE_C
 
 /**
  * \def MBEDTLS_RIPEMD160_C
@@ -3333,7 +3333,7 @@
  *
  * Module:  library/timing.c
  */
-#define MBEDTLS_TIMING_C
+//#define MBEDTLS_TIMING_C
 
 /**
  * \def MBEDTLS_VERSION_C
@@ -3886,7 +3886,7 @@
  * C standards (e.g using memset_s() in C11) or calling a secure memset() from
  * their system (e.g explicit_bzero() in BSD).
  */
-//#define MBEDTLS_PLATFORM_ZEROIZE_ALT
+#define MBEDTLS_PLATFORM_ZEROIZE_ALT
 
 /**
  * Uncomment the macro to let Mbed TLS use your alternate implementation of
diff --git a/include/mbedtls/md.h b/include/mbedtls/md.h
index 7bad24dc9..9dbc42b47 100644
--- a/include/mbedtls/md.h
+++ b/include/mbedtls/md.h
@@ -149,6 +149,7 @@ typedef enum {
     MBEDTLS_MD_SHA384,    /**< The SHA-384 message digest. */
     MBEDTLS_MD_SHA512,    /**< The SHA-512 message digest. */
     MBEDTLS_MD_RIPEMD160, /**< The RIPEMD-160 message digest. */
+    MBEDTLS_MD_KEYSTONE_SHA3, // new_impl: Keystone SHA3 message digest
 } mbedtls_md_type_t;
 
 #if defined(MBEDTLS_MD_CAN_SHA512)
diff --git a/include/mbedtls/oid.h b/include/mbedtls/oid.h
index a72f51c4f..7e4bea478 100644
--- a/include/mbedtls/oid.h
+++ b/include/mbedtls/oid.h
@@ -63,6 +63,10 @@
 #define MBEDTLS_OID_X509_EXT_FRESHEST_CRL                (1 << 14)
 #define MBEDTLS_OID_X509_EXT_NS_CERT_TYPE                (1 << 16)
 
+#define MBEDTLS_OID_X509_EXT_NONCE                       (1 << 24) // new_impl  
+#define MBEDTLS_OID_X509_EXT_DICE_CERTS                  (1 << 25) // new_impl
+#define MBEDTLS_OID_X509_EXT_ATTESTATION_PROOF           (1 << 26) // new_impl
+
 /*
  * Top level OID tuples
  */
@@ -437,6 +441,11 @@
  *   ecdsa-with-SHA2(3) 4 } */
 #define MBEDTLS_OID_ECDSA_SHA512            MBEDTLS_OID_ANSI_X9_62_SIG_SHA2 "\x04"
 
+/* new_impl: OIDs for CSR extensions */
+#define MBEDTLS_OID_NONCE               "\x2b\x65\x60"
+#define MBEDTLS_OID_DICE_CERTS          "\x2b\x65\x61"
+#define MBEDTLS_OID_ATTESTATION_PROOF   "\x2b\x65\x62"
+
 #ifdef __cplusplus
 extern "C" {
 #endif
diff --git a/include/mbedtls/pk.h b/include/mbedtls/pk.h
index c579661b3..28acffe9e 100644
--- a/include/mbedtls/pk.h
+++ b/include/mbedtls/pk.h
@@ -91,6 +91,7 @@ typedef enum {
     MBEDTLS_PK_RSA_ALT,
     MBEDTLS_PK_RSASSA_PSS,
     MBEDTLS_PK_OPAQUE,
+    MBEDTLS_PK_ED25519, // new_impl: Ed25519
 } mbedtls_pk_type_t;
 
 /**
diff --git a/include/mbedtls/platform.h b/include/mbedtls/platform.h
index f65158719..97fafd92c 100644
--- a/include/mbedtls/platform.h
+++ b/include/mbedtls/platform.h
@@ -465,6 +465,23 @@ int mbedtls_platform_setup(mbedtls_platform_context *ctx);
  */
 void mbedtls_platform_teardown(mbedtls_platform_context *ctx);
 
+int atoi(const char *nptr);
+
+int rand(void);
+void srand(unsigned int seed);
+
+size_t strlen(const char *str);
+int strcmp(const char *string1, const char *string2);
+int strncmp(const char *string1, const char *string2, size_t count);
+char *strncpy(char *strDest, const char *strSource, size_t count);
+char *strchr(const char *str, int c);
+char *strstr(const char *str, const char *strSearch);
+
+void *memmove(void *dest, const void *src, size_t count);
+int memcmp(const void *buffer1, const void *buffer2, size_t count);
+void *memset(void *dest, int c, size_t count);
+void *memcpy(void *dest, const void *src, size_t count);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/include/mbedtls/x509.h b/include/mbedtls/x509.h
index 8dfd1f364..23507647d 100644
--- a/include/mbedtls/x509.h
+++ b/include/mbedtls/x509.h
@@ -200,6 +200,10 @@
 #define MBEDTLS_X509_EXT_FRESHEST_CRL             MBEDTLS_OID_X509_EXT_FRESHEST_CRL
 #define MBEDTLS_X509_EXT_NS_CERT_TYPE             MBEDTLS_OID_X509_EXT_NS_CERT_TYPE
 
+#define MBEDTLS_X509_EXT_NONCE                    MBEDTLS_OID_X509_EXT_NONCE                // new_impl  
+#define MBEDTLS_X509_EXT_DICE_CERTS               MBEDTLS_OID_X509_EXT_DICE_CERTS           // new_impl
+#define MBEDTLS_X509_EXT_ATTESTATION_PROOF        MBEDTLS_OID_X509_EXT_ATTESTATION_PROOF    // new_impl
+
 /*
  * Storage format identifiers
  * Recognized formats: PEM and DER
diff --git a/include/mbedtls/x509_crt.h b/include/mbedtls/x509_crt.h
index 6c86a6629..f7d2de143 100644
--- a/include/mbedtls/x509_crt.h
+++ b/include/mbedtls/x509_crt.h
@@ -77,6 +77,8 @@ typedef struct mbedtls_x509_crt {
     mbedtls_x509_buf v3_ext;            /**< Optional X.509 v3 extensions.  */
     mbedtls_x509_sequence subject_alt_names;    /**< Optional list of raw entries of Subject Alternative Names extension (currently only dNSName, uniformResourceIdentifier, DirectoryName and OtherName are listed). */
 
+    mbedtls_x509_buf hash; // new_impl: TCI of the subject
+
     mbedtls_x509_sequence certificate_policies; /**< Optional list of certificate policies (Only anyPolicy is printed and enforced, however the rest of the policies are still listed). */
 
     int MBEDTLS_PRIVATE(ext_types);              /**< Bit string containing detected and parsed extensions */
@@ -336,6 +338,9 @@ extern const mbedtls_x509_crt_profile mbedtls_x509_crt_profile_suiteb;
  */
 extern const mbedtls_x509_crt_profile mbedtls_x509_crt_profile_none;
 
+/* new_impl: Profile for Keystone user */
+extern const mbedtls_x509_crt_profile mbedtls_x509_crt_profile_keystone;
+
 /**
  * \brief          Parse a single DER formatted certificate and add it
  *                 to the end of the provided chained list.
diff --git a/include/mbedtls/x509_csr.h b/include/mbedtls/x509_csr.h
index f3f9e13a0..60d7cf97c 100644
--- a/include/mbedtls/x509_csr.h
+++ b/include/mbedtls/x509_csr.h
@@ -26,6 +26,7 @@
 #include "mbedtls/build_info.h"
 
 #include "mbedtls/x509.h"
+#include "mbedtls/x509_crt.h"
 
 #ifdef __cplusplus
 extern "C" {
@@ -62,6 +63,10 @@ typedef struct mbedtls_x509_csr {
     unsigned char ns_cert_type; /**< Optional Netscape certificate type extension value: See the values in x509.h */
     mbedtls_x509_sequence subject_alt_names;    /**< Optional list of raw entries of Subject Alternative Names extension (currently only dNSName and OtherName are listed). */
 
+    mbedtls_x509_crt cert_chain;            // new_impl: chain of DICE certificates
+    mbedtls_x509_buf nonce;                 // new_impl: nonce sent by the verifier
+    mbedtls_x509_buf attestation_proof;     // new_impl: attestation evidence
+
     int MBEDTLS_PRIVATE(ext_types);              /**< Bit string containing detected and parsed extensions */
 
     mbedtls_x509_buf sig_oid;
diff --git a/library/alignment.h b/library/alignment.h
index 41823485a..647118308 100644
--- a/library/alignment.h
+++ b/library/alignment.h
@@ -189,6 +189,7 @@ inline void mbedtls_put_unaligned_uint64(void *p, uint64_t x)
  * compiler may be able to detect and transform into the relevant bswap or
  * similar instruction.
  */
+#undef MBEDTLS_BSWAP16
 #if !defined(MBEDTLS_BSWAP16)
 static inline uint16_t mbedtls_bswap16(uint16_t x)
 {
@@ -199,6 +200,7 @@ static inline uint16_t mbedtls_bswap16(uint16_t x)
 #define MBEDTLS_BSWAP16 mbedtls_bswap16
 #endif /* !defined(MBEDTLS_BSWAP16) */
 
+#undef MBEDTLS_BSWAP32
 #if !defined(MBEDTLS_BSWAP32)
 static inline uint32_t mbedtls_bswap32(uint32_t x)
 {
@@ -211,6 +213,7 @@ static inline uint32_t mbedtls_bswap32(uint32_t x)
 #define MBEDTLS_BSWAP32 mbedtls_bswap32
 #endif /* !defined(MBEDTLS_BSWAP32) */
 
+#undef MBEDTLS_BSWAP64
 #if !defined(MBEDTLS_BSWAP64)
 static inline uint64_t mbedtls_bswap64(uint64_t x)
 {
diff --git a/library/asn1parse.c b/library/asn1parse.c
index d257ef438..91f33b9e7 100644
--- a/library/asn1parse.c
+++ b/library/asn1parse.c
@@ -95,6 +95,9 @@ int mbedtls_asn1_get_len(unsigned char **p,
         return MBEDTLS_ERR_ASN1_OUT_OF_DATA;
     }
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("mbedtls_asn1_get_len - len = %lu\n", *len);
+    #endif
     return 0;
 }
 
@@ -112,6 +115,9 @@ int mbedtls_asn1_get_tag(unsigned char **p,
 
     (*p)++;
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("mbedtls_asn1_get_tag - tag = %02x\n", tag);
+    #endif
     return mbedtls_asn1_get_len(p, end, len);
 }
 
@@ -133,6 +139,9 @@ int mbedtls_asn1_get_bool(unsigned char **p,
     *val = (**p != 0) ? 1 : 0;
     (*p)++;
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("mbedtls_asn1_get_bool - bool = %d\n", *val);
+    #endif
     return 0;
 }
 
@@ -180,6 +189,9 @@ static int asn1_get_tagged_int(unsigned char **p,
         (*p)++;
     }
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("asn1_get_tagged_int - int = %d\n", *val);
+    #endif
     return 0;
 }
 
@@ -325,6 +337,10 @@ int mbedtls_asn1_get_bitstring_null(unsigned char **p, const unsigned char *end,
     }
     ++(*p);
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("mbedtls_asn1_get_bitstring_null - len = %lu\n", *len);
+    #endif
+
     return 0;
 }
 
@@ -333,6 +349,9 @@ void mbedtls_asn1_sequence_free(mbedtls_asn1_sequence *seq)
     while (seq != NULL) {
         mbedtls_asn1_sequence *next = seq->next;
         mbedtls_free(seq);
+        #if MBEDTLS_DEBUG_PRINTS
+        mbedtls_printf("mbedtls_asn1_sequence_free - free: %lu\n", sizeof(mbedtls_asn1_sequence));
+        #endif
         seq = next;
     }
 }
@@ -412,6 +431,11 @@ int mbedtls_asn1_get_alg(unsigned char **p,
     alg->p = *p;
     *p += alg->len;
 
+    #if MBEDTLS_DEBUG_PRINTS
+    print_hex_string("mbedtls_asn1_get_alg - alg", alg->p, alg->len);
+    mbedtls_printf("mbedtls_asn1_get_alg - alg_tag = %02x\n", alg->tag);
+    #endif
+
     if (*p == end) {
         mbedtls_platform_zeroize(params, sizeof(mbedtls_asn1_buf));
         return 0;
@@ -431,6 +455,11 @@ int mbedtls_asn1_get_alg(unsigned char **p,
         return MBEDTLS_ERR_ASN1_LENGTH_MISMATCH;
     }
 
+    #if MBEDTLS_DEBUG_PRINTS
+    print_hex_string("mbedtls_asn1_get_alg - params", params->p, params->len);
+    mbedtls_printf("mbedtls_asn1_get_alg - params_tag = %02x\n", params->tag);
+    #endif
+
     return 0;
 }
 
@@ -475,8 +504,17 @@ void mbedtls_asn1_free_named_data_list(mbedtls_asn1_named_data **head)
     while ((cur = *head) != NULL) {
         *head = cur->next;
         mbedtls_free(cur->oid.p);
+        #if MBEDTLS_DEBUG_PRINTS
+        mbedtls_printf("mbedtls_asn1_free_named_data_list - free: %lu\n", cur->oid.len);
+        #endif
         mbedtls_free(cur->val.p);
+        #if MBEDTLS_DEBUG_PRINTS
+        mbedtls_printf("mbedtls_asn1_free_named_data_list - free: %lu\n", cur->val.len);
+        #endif
         mbedtls_free(cur);
+        #if MBEDTLS_DEBUG_PRINTS
+        mbedtls_printf("mbedtls_asn1_free_named_data_list - free: %lu\n", sizeof(mbedtls_asn1_named_data));
+        #endif
     }
 }
 
@@ -485,6 +523,9 @@ void mbedtls_asn1_free_named_data_list_shallow(mbedtls_asn1_named_data *name)
     for (mbedtls_asn1_named_data *next; name != NULL; name = next) {
         next = name->next;
         mbedtls_free(name);
+        #if MBEDTLS_DEBUG_PRINTS
+        mbedtls_printf("mbedtls_asn1_free_named_data_list_shallow - free: %lu\n", sizeof(mbedtls_asn1_named_data));
+        #endif
     }
 }
 
diff --git a/library/asn1write.c b/library/asn1write.c
index b9d586aef..c0296814a 100644
--- a/library/asn1write.c
+++ b/library/asn1write.c
@@ -30,6 +30,9 @@
 
 int mbedtls_asn1_write_len(unsigned char **p, const unsigned char *start, size_t len)
 {
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("mbedtls_asn1_write_len - len = %lu\n", len);
+    #endif
     if (len < 0x80) {
         if (*p - start < 1) {
             return MBEDTLS_ERR_ASN1_BUF_TOO_SMALL;
@@ -73,9 +76,11 @@ int mbedtls_asn1_write_len(unsigned char **p, const unsigned char *start, size_t
     }
 
     int len_is_valid = 1;
+    /* // new_impl
 #if SIZE_MAX > 0xFFFFFFFF
     len_is_valid = (len <= 0xFFFFFFFF);
 #endif
+    */
     if (len_is_valid) {
         if (*p - start < 5) {
             return MBEDTLS_ERR_ASN1_BUF_TOO_SMALL;
@@ -94,6 +99,9 @@ int mbedtls_asn1_write_len(unsigned char **p, const unsigned char *start, size_t
 
 int mbedtls_asn1_write_tag(unsigned char **p, const unsigned char *start, unsigned char tag)
 {
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("mbedtls_asn1_write_tag - tag = %02x\n", tag);
+    #endif
     if (*p - start < 1) {
         return MBEDTLS_ERR_ASN1_BUF_TOO_SMALL;
     }
@@ -106,6 +114,9 @@ int mbedtls_asn1_write_tag(unsigned char **p, const unsigned char *start, unsign
 int mbedtls_asn1_write_raw_buffer(unsigned char **p, const unsigned char *start,
                                   const unsigned char *buf, size_t size)
 {
+    #if MBEDTLS_DEBUG_PRINTS
+    print_hex_string("mbedtls_asn1_write_raw_buffer - buf", (unsigned char *) buf, (int)size);
+    #endif
     size_t len = 0;
 
     if (*p < start || (size_t) (*p - start) < size) {
@@ -166,6 +177,9 @@ cleanup:
 
 int mbedtls_asn1_write_null(unsigned char **p, const unsigned char *start)
 {
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("mbedtls_asn1_write_null\n");
+    #endif
     int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
     size_t len = 0;
 
@@ -180,6 +194,9 @@ int mbedtls_asn1_write_null(unsigned char **p, const unsigned char *start)
 int mbedtls_asn1_write_oid(unsigned char **p, const unsigned char *start,
                            const char *oid, size_t oid_len)
 {
+    #if MBEDTLS_DEBUG_PRINTS
+    print_hex_string("mbedtls_asn1_write_oid - buf", (unsigned char *)oid, (int)oid_len);
+    #endif
     int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
     size_t len = 0;
 
@@ -195,6 +212,9 @@ int mbedtls_asn1_write_algorithm_identifier(unsigned char **p, const unsigned ch
                                             const char *oid, size_t oid_len,
                                             size_t par_len)
 {
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("mbedtls_asn1_write_algorithm_identifier\n");
+    #endif
     int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
     size_t len = 0;
 
@@ -216,6 +236,9 @@ int mbedtls_asn1_write_algorithm_identifier(unsigned char **p, const unsigned ch
 
 int mbedtls_asn1_write_bool(unsigned char **p, const unsigned char *start, int boolean)
 {
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("mbedtls_asn1_write_bool - bool = %d\n", boolean);
+    #endif
     int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
     size_t len = 0;
 
@@ -234,6 +257,9 @@ int mbedtls_asn1_write_bool(unsigned char **p, const unsigned char *start, int b
 
 static int asn1_write_tagged_int(unsigned char **p, const unsigned char *start, int val, int tag)
 {
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("asn1_write_tagged_int - val = %d, tag = %d\n", val, tag);
+    #endif
     int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
     size_t len = 0;
 
@@ -262,6 +288,9 @@ static int asn1_write_tagged_int(unsigned char **p, const unsigned char *start,
 
 int mbedtls_asn1_write_int(unsigned char **p, const unsigned char *start, int val)
 {
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("mbedtls_asn1_write_int - val = %d\n", val);
+    #endif
     return asn1_write_tagged_int(p, start, val, MBEDTLS_ASN1_INTEGER);
 }
 
@@ -273,6 +302,10 @@ int mbedtls_asn1_write_enum(unsigned char **p, const unsigned char *start, int v
 int mbedtls_asn1_write_tagged_string(unsigned char **p, const unsigned char *start, int tag,
                                      const char *text, size_t text_len)
 {
+    #if MBEDTLS_DEBUG_PRINTS
+    print_hex_string("mbedtls_asn1_write_tagged_string - buf", (unsigned char*)text, text_len);
+    mbedtls_printf("mbedtls_asn1_write_tagged_string - tag = %d\n", tag);
+    #endif
     int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
     size_t len = 0;
 
@@ -432,13 +465,24 @@ mbedtls_asn1_named_data *mbedtls_asn1_store_named_data(
             return NULL;
         }
 
+        #if MBEDTLS_DEBUG_PRINTS
+        mbedtls_printf("mbedtls_asn1_store_named_data - calloc: %lu\n", sizeof(mbedtls_asn1_named_data));
+        #endif
+
         cur->oid.len = oid_len;
         cur->oid.p = mbedtls_calloc(1, oid_len);
         if (cur->oid.p == NULL) {
             mbedtls_free(cur);
+            #if MBEDTLS_DEBUG_PRINTS
+            mbedtls_printf("mbedtls_asn1_store_named_data - free: %lu\n", sizeof(mbedtls_asn1_named_data));
+            #endif
             return NULL;
         }
 
+        #if MBEDTLS_DEBUG_PRINTS
+        mbedtls_printf("mbedtls_asn1_store_named_data - calloc: %lu\n", oid_len);
+        #endif
+
         memcpy(cur->oid.p, oid, oid_len);
 
         cur->val.len = val_len;
@@ -446,15 +490,27 @@ mbedtls_asn1_named_data *mbedtls_asn1_store_named_data(
             cur->val.p = mbedtls_calloc(1, val_len);
             if (cur->val.p == NULL) {
                 mbedtls_free(cur->oid.p);
+                #if MBEDTLS_DEBUG_PRINTS
+                mbedtls_printf("mbedtls_asn1_store_named_data - free: %lu\n", cur->val.len);
+                #endif
                 mbedtls_free(cur);
+                #if MBEDTLS_DEBUG_PRINTS
+                mbedtls_printf("mbedtls_asn1_store_named_data - free: %lu\n", sizeof(mbedtls_asn1_named_data));
+                #endif
                 return NULL;
             }
+            #if MBEDTLS_DEBUG_PRINTS
+            mbedtls_printf("mbedtls_asn1_store_named_data - calloc: %lu\n", val_len);
+            #endif
         }
 
         cur->next = *head;
         *head = cur;
     } else if (val_len == 0) {
         mbedtls_free(cur->val.p);
+        #if MBEDTLS_DEBUG_PRINTS
+        mbedtls_printf("mbedtls_asn1_store_named_data - free: %lu\n", cur->val.len);
+        #endif
         cur->val.p = NULL;
     } else if (cur->val.len != val_len) {
         /*
@@ -467,7 +523,13 @@ mbedtls_asn1_named_data *mbedtls_asn1_store_named_data(
             return NULL;
         }
 
+        #if MBEDTLS_DEBUG_PRINTS
+        mbedtls_printf("mbedtls_asn1_store_named_data - calloc: %lu\n", val_len);
+        #endif
         mbedtls_free(cur->val.p);
+        #if MBEDTLS_DEBUG_PRINTS
+        mbedtls_printf("mbedtls_asn1_store_named_data - free: %lu\n", cur->val.len);
+        #endif
         cur->val.p = p;
         cur->val.len = val_len;
     }
diff --git a/library/ctr_drbg.c b/library/ctr_drbg.c
index acc4208cc..d314ede27 100644
--- a/library/ctr_drbg.c
+++ b/library/ctr_drbg.c
@@ -348,16 +348,20 @@ static int mbedtls_ctr_drbg_reseed_internal(mbedtls_ctr_drbg_context *ctx,
     size_t seedlen = 0;
     int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
 
+    mbedtls_printf("mbedtls_ctr_drbg_reseed_internal - 1\n");
     if (ctx->entropy_len > MBEDTLS_CTR_DRBG_MAX_SEED_INPUT) {
         return MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG;
     }
+    mbedtls_printf("mbedtls_ctr_drbg_reseed_internal - 2\n");
     if (nonce_len > MBEDTLS_CTR_DRBG_MAX_SEED_INPUT - ctx->entropy_len) {
         return MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG;
     }
+    mbedtls_printf("mbedtls_ctr_drbg_reseed_internal - 3\n");
     if (len > MBEDTLS_CTR_DRBG_MAX_SEED_INPUT - ctx->entropy_len - nonce_len) {
         return MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG;
     }
 
+    mbedtls_printf("mbedtls_ctr_drbg_reseed_internal - 4\n");
     memset(seed, 0, MBEDTLS_CTR_DRBG_MAX_SEED_INPUT);
 
     /* Gather entropy_len bytes of entropy to seed state. */
@@ -366,6 +370,7 @@ static int mbedtls_ctr_drbg_reseed_internal(mbedtls_ctr_drbg_context *ctx,
     }
     seedlen += ctx->entropy_len;
 
+    mbedtls_printf("mbedtls_ctr_drbg_reseed_internal - 5\n");
     /* Gather entropy for a nonce if requested. */
     if (nonce_len != 0) {
         if (0 != ctx->f_entropy(ctx->p_entropy, seed + seedlen, nonce_len)) {
@@ -374,23 +379,27 @@ static int mbedtls_ctr_drbg_reseed_internal(mbedtls_ctr_drbg_context *ctx,
         seedlen += nonce_len;
     }
 
+    mbedtls_printf("mbedtls_ctr_drbg_reseed_internal - 6\n");
     /* Add additional data if provided. */
     if (additional != NULL && len != 0) {
         memcpy(seed + seedlen, additional, len);
         seedlen += len;
     }
 
+    mbedtls_printf("mbedtls_ctr_drbg_reseed_internal - 7\n");
     /* Reduce to 384 bits. */
     if ((ret = block_cipher_df(seed, seed, seedlen)) != 0) {
         goto exit;
     }
 
+    mbedtls_printf("mbedtls_ctr_drbg_reseed_internal - 8\n");
     /* Update state. */
     if ((ret = ctr_drbg_update_internal(ctx, seed)) != 0) {
         goto exit;
     }
     ctx->reseed_counter = 1;
 
+    mbedtls_printf("mbedtls_ctr_drbg_reseed_internal - 9\n");
 exit:
     mbedtls_platform_zeroize(seed, sizeof(seed));
     return ret;
@@ -458,17 +467,20 @@ int mbedtls_ctr_drbg_seed(mbedtls_ctr_drbg_context *ctx,
                  (size_t) ctx->reseed_counter :
                  good_nonce_len(ctx->entropy_len));
 
+    mbedtls_printf("mbedtls_ctr_drbg_seed - 1\n");
     /* Initialize with an empty key. */
     if ((ret = mbedtls_aes_setkey_enc(&ctx->aes_ctx, key,
                                       MBEDTLS_CTR_DRBG_KEYBITS)) != 0) {
         return ret;
     }
 
+    mbedtls_printf("mbedtls_ctr_drbg_seed - 2\n");
     /* Do the initial seeding. */
     if ((ret = mbedtls_ctr_drbg_reseed_internal(ctx, custom, len,
                                                 nonce_len)) != 0) {
         return ret;
     }
+    mbedtls_printf("mbedtls_ctr_drbg_seed - 3\n");
     return 0;
 }
 
diff --git a/library/entropy.c b/library/entropy.c
index 00079176a..b72231a17 100644
--- a/library/entropy.c
+++ b/library/entropy.c
@@ -211,10 +211,12 @@ static int entropy_gather_internal(mbedtls_entropy_context *ctx)
     unsigned char buf[MBEDTLS_ENTROPY_MAX_GATHER];
     size_t olen;
 
+    mbedtls_printf("entropy_gather_internal - 1\n");
     if (ctx->source_count == 0) {
         return MBEDTLS_ERR_ENTROPY_NO_SOURCES_DEFINED;
     }
 
+    mbedtls_printf("entropy_gather_internal - 2\n");
     /*
      * Run through our entropy sources
      */
@@ -229,6 +231,7 @@ static int entropy_gather_internal(mbedtls_entropy_context *ctx)
             goto cleanup;
         }
 
+        mbedtls_printf("entropy_gather_internal - 3\n");
         /*
          * Add if we actually gathered something
          */
@@ -239,12 +242,15 @@ static int entropy_gather_internal(mbedtls_entropy_context *ctx)
             }
             ctx->source[i].size += olen;
         }
+        mbedtls_printf("entropy_gather_internal - 4\n");
     }
 
+    mbedtls_printf("entropy_gather_internal - 5\n");
     if (have_one_strong == 0) {
         ret = MBEDTLS_ERR_ENTROPY_NO_STRONG_SOURCE;
     }
 
+    mbedtls_printf("entropy_gather_internal - 6\n");
 cleanup:
     mbedtls_platform_zeroize(buf, sizeof(buf));
 
@@ -282,6 +288,7 @@ int mbedtls_entropy_func(void *data, unsigned char *output, size_t len)
     mbedtls_entropy_context *ctx = (mbedtls_entropy_context *) data;
     unsigned char buf[MBEDTLS_ENTROPY_BLOCK_SIZE];
 
+    mbedtls_printf("mbedtls_entropy_func - 1\n");
     if (len > MBEDTLS_ENTROPY_BLOCK_SIZE) {
         return MBEDTLS_ERR_ENTROPY_SOURCE_FAILED;
     }
@@ -304,6 +311,7 @@ int mbedtls_entropy_func(void *data, unsigned char *output, size_t len)
     }
 #endif
 
+    mbedtls_printf("mbedtls_entropy_func - 2\n");
     /*
      * Always gather extra entropy before a call
      */
@@ -313,10 +321,12 @@ int mbedtls_entropy_func(void *data, unsigned char *output, size_t len)
             goto exit;
         }
 
+        mbedtls_printf("mbedtls_entropy_func - 3\n");
         if ((ret = entropy_gather_internal(ctx)) != 0) {
             goto exit;
         }
 
+        mbedtls_printf("mbedtls_entropy_func - 4\n");
         thresholds_reached = 1;
         strong_size = 0;
         for (i = 0; i < ctx->source_count; i++) {
@@ -331,6 +341,7 @@ int mbedtls_entropy_func(void *data, unsigned char *output, size_t len)
 
     memset(buf, 0, MBEDTLS_ENTROPY_BLOCK_SIZE);
 
+    mbedtls_printf("mbedtls_entropy_func - 5\n");
     /*
      * Note that at this stage it is assumed that the accumulator was started
      * in a previous call to entropy_update(). If this is not guaranteed, the
@@ -340,6 +351,7 @@ int mbedtls_entropy_func(void *data, unsigned char *output, size_t len)
         goto exit;
     }
 
+    mbedtls_printf("mbedtls_entropy_func - 6\n");
     /*
      * Reset accumulator and counters and recycle existing entropy
      */
@@ -350,15 +362,18 @@ int mbedtls_entropy_func(void *data, unsigned char *output, size_t len)
     if (ret != 0) {
         goto exit;
     }
+    mbedtls_printf("mbedtls_entropy_func - 7\n");
     ret = mbedtls_md_starts(&ctx->accumulator);
     if (ret != 0) {
         goto exit;
     }
+    mbedtls_printf("mbedtls_entropy_func - 8\n");
     if ((ret = mbedtls_md_update(&ctx->accumulator, buf,
                                  MBEDTLS_ENTROPY_BLOCK_SIZE)) != 0) {
         goto exit;
     }
 
+    mbedtls_printf("mbedtls_entropy_func - 9\n");
     /*
      * Perform second hashing on entropy
      */
@@ -367,6 +382,7 @@ int mbedtls_entropy_func(void *data, unsigned char *output, size_t len)
         goto exit;
     }
 
+    mbedtls_printf("mbedtls_entropy_func - 10\n");
     for (i = 0; i < ctx->source_count; i++) {
         ctx->source[i].size = 0;
     }
@@ -384,6 +400,7 @@ exit:
     }
 #endif
 
+    mbedtls_printf("mbedtls_entropy_func - 11\n");
     return ret;
 }
 
diff --git a/library/hash_info.c b/library/hash_info.c
index 37e44c6bd..bee74f45e 100644
--- a/library/hash_info.c
+++ b/library/hash_info.c
@@ -52,6 +52,7 @@ static const hash_entry hash_table[] = {
 #if defined(MBEDTLS_MD_CAN_SHA512)
     { PSA_ALG_SHA_512, MBEDTLS_MD_SHA512, 64, 128 },
 #endif
+    { PSA_ALG_ANY_HASH, MBEDTLS_MD_KEYSTONE_SHA3, 64, 72},
     { PSA_ALG_NONE, MBEDTLS_MD_NONE, 0, 0 },
 };
 
diff --git a/library/md.c b/library/md.c
index bebe3580b..2aa0b6ed7 100644
--- a/library/md.c
+++ b/library/md.c
@@ -65,6 +65,9 @@
 #include <stdio.h>
 #endif
 
+#include "keystone_ext.h"
+#include "sha3/sha3.h"
+
 #if defined(MBEDTLS_MD_CAN_MD5)
 const mbedtls_md_info_t mbedtls_md5_info = {
     "MD5",
@@ -128,6 +131,13 @@ const mbedtls_md_info_t mbedtls_sha512_info = {
 };
 #endif
 
+const mbedtls_md_info_t mbedtls_keystone_sha3_info = {
+    "KEYSTONE_SHA3",
+    MBEDTLS_MD_KEYSTONE_SHA3,
+    MBEDTLS_HASH_MAX_SIZE,
+    200 - 2*MBEDTLS_HASH_MAX_SIZE,
+};
+
 const mbedtls_md_info_t *mbedtls_md_info_from_type(mbedtls_md_type_t md_type)
 {
     switch (md_type) {
@@ -159,6 +169,8 @@ const mbedtls_md_info_t *mbedtls_md_info_from_type(mbedtls_md_type_t md_type)
         case MBEDTLS_MD_SHA512:
             return &mbedtls_sha512_info;
 #endif
+        case MBEDTLS_MD_KEYSTONE_SHA3:
+            return &mbedtls_keystone_sha3_info;
         default:
             return NULL;
     }
@@ -644,6 +656,9 @@ int mbedtls_md(const mbedtls_md_info_t *md_info, const unsigned char *input, siz
         case MBEDTLS_MD_SHA512:
             return mbedtls_sha512(input, ilen, output, 0);
 #endif
+        case MBEDTLS_MD_KEYSTONE_SHA3:
+            sha3(input, ilen, output, MBEDTLS_HASH_MAX_SIZE);
+            return 0;
         default:
             return MBEDTLS_ERR_MD_BAD_INPUT_DATA;
     }
diff --git a/library/oid.c b/library/oid.c
index 80cadcd53..d0b99eab9 100644
--- a/library/oid.c
+++ b/library/oid.c
@@ -318,6 +318,24 @@ static const oid_x509_ext_t oid_x509_ext[] =
                        "Certificate Policies"),
         MBEDTLS_OID_X509_EXT_CERTIFICATE_POLICIES,
     },
+    {   // new_impl
+        OID_DESCRIPTOR(MBEDTLS_OID_NONCE,
+                       "id-keystone-nonce",
+                       "Nonce"),
+        MBEDTLS_OID_X509_EXT_NONCE,
+    },
+    {   // new_impl
+        OID_DESCRIPTOR(MBEDTLS_OID_DICE_CERTS,
+                       "id-keystone-diceCertificates",
+                       "DICE Certificates"),
+        MBEDTLS_OID_X509_EXT_DICE_CERTS,
+    },
+    {   // new_impl
+        OID_DESCRIPTOR(MBEDTLS_OID_ATTESTATION_PROOF,
+                       "id-keystone-attestationProof",
+                       "Attestation Proof"),
+        MBEDTLS_OID_X509_EXT_ATTESTATION_PROOF,
+    },
     {
         NULL_OID_DESCRIPTOR,
         0,
@@ -464,6 +482,10 @@ static const oid_sig_alg_t oid_sig_alg[] =
         MBEDTLS_MD_NONE,     MBEDTLS_PK_RSASSA_PSS,
     },
 #endif /* MBEDTLS_RSA_C */
+    {
+        OID_DESCRIPTOR("\x2b\x65\x70",                "ed25519",              "ed25519 with sha3"),
+        MBEDTLS_MD_KEYSTONE_SHA3, MBEDTLS_PK_ED25519,
+    },
     {
         NULL_OID_DESCRIPTOR,
         MBEDTLS_MD_NONE, MBEDTLS_PK_NONE,
@@ -517,6 +539,10 @@ static const oid_pk_alg_t oid_pk_alg[] =
         OID_DESCRIPTOR(MBEDTLS_OID_EC_ALG_ECDH,         "id-ecDH",          "EC key for ECDH"),
         MBEDTLS_PK_ECKEY_DH,
     },
+    {
+        OID_DESCRIPTOR("\x2b\x65\x70",                  "ed25519",          "Keystone Ed25519 algo"),
+        MBEDTLS_PK_ED25519,
+    },
     {
         NULL_OID_DESCRIPTOR,
         MBEDTLS_PK_NONE,
diff --git a/library/pk.c b/library/pk.c
index a93ed56ea..61953112b 100644
--- a/library/pk.c
+++ b/library/pk.c
@@ -126,6 +126,8 @@ const mbedtls_pk_info_t *mbedtls_pk_info_from_type(mbedtls_pk_type_t pk_type)
             return &mbedtls_ecdsa_info;
 #endif /* MBEDTLS_PK_CAN_ECDSA_SOME */
         /* MBEDTLS_PK_RSA_ALT omitted on purpose */
+        case MBEDTLS_PK_ED25519:
+            return &mbedtls_ed25519_info;
         default:
             return NULL;
     }
@@ -137,10 +139,16 @@ const mbedtls_pk_info_t *mbedtls_pk_info_from_type(mbedtls_pk_type_t pk_type)
 int mbedtls_pk_setup(mbedtls_pk_context *ctx, const mbedtls_pk_info_t *info)
 {
     if (info == NULL || ctx->pk_info != NULL) {
+        #if MBEDTLS_DEBUG_PRINTS
+        mbedtls_printf("PK - pk setup: err 1\n");
+        #endif
         return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
     }
 
     if ((ctx->pk_ctx = info->ctx_alloc_func()) == NULL) {
+        #if MBEDTLS_DEBUG_PRINTS
+        mbedtls_printf("PK - pk setup: err 2\n");
+        #endif
         return MBEDTLS_ERR_PK_ALLOC_FAILED;
     }
 
@@ -424,11 +432,13 @@ int mbedtls_pk_verify_restartable(mbedtls_pk_context *ctx,
                                   mbedtls_pk_restart_ctx *rs_ctx)
 {
     if ((md_alg != MBEDTLS_MD_NONE || hash_len != 0) && hash == NULL) {
+        mbedtls_printf("mbedtls_pk_verify_restartable - exit 1\n");
         return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
     }
 
     if (ctx->pk_info == NULL ||
         pk_hashlen_helper(md_alg, &hash_len) != 0) {
+        mbedtls_printf("mbedtls_pk_verify_restartable - exit 2\n");
         return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
     }
 
@@ -457,6 +467,7 @@ int mbedtls_pk_verify_restartable(mbedtls_pk_context *ctx,
 #endif /* MBEDTLS_ECDSA_C && MBEDTLS_ECP_RESTARTABLE */
 
     if (ctx->pk_info->verify_func == NULL) {
+        mbedtls_printf("mbedtls_pk_verify_restartable - exit 3\n");
         return MBEDTLS_ERR_PK_TYPE_MISMATCH;
     }
 
@@ -484,25 +495,30 @@ int mbedtls_pk_verify_ext(mbedtls_pk_type_t type, const void *options,
                           const unsigned char *sig, size_t sig_len)
 {
     if ((md_alg != MBEDTLS_MD_NONE || hash_len != 0) && hash == NULL) {
+        mbedtls_printf("mbedtls_pk_verify_ext - exit 1\n");
         return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
     }
 
     if (ctx->pk_info == NULL) {
+        mbedtls_printf("mbedtls_pk_verify_ext - exit 2\n");
         return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
     }
 
     if (!mbedtls_pk_can_do(ctx, type)) {
+        mbedtls_printf("mbedtls_pk_verify_ext - exit 3\n");
         return MBEDTLS_ERR_PK_TYPE_MISMATCH;
     }
 
     if (type != MBEDTLS_PK_RSASSA_PSS) {
         /* General case: no options */
         if (options != NULL) {
+            mbedtls_printf("mbedtls_pk_verify_ext - exit 4\n");
             return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
         }
 
         return mbedtls_pk_verify(ctx, md_alg, hash, hash_len, sig, sig_len);
     }
+    mbedtls_printf("mbedtls_pk_verify_ext - exit 5\n");
 
 #if defined(MBEDTLS_RSA_C) && defined(MBEDTLS_PKCS1_V21)
     int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
diff --git a/library/pk_wrap.c b/library/pk_wrap.c
index 57bfdcaa2..2479c5d95 100644
--- a/library/pk_wrap.c
+++ b/library/pk_wrap.c
@@ -19,6 +19,8 @@
 
 #include "common.h"
 
+#include "keystone_ext.h"
+
 #include "mbedtls/platform_util.h"
 
 #if defined(MBEDTLS_PK_C)
@@ -614,6 +616,20 @@ static void rsa_debug(const void *ctx, mbedtls_pk_debug_item *items)
 #endif
 }
 
+const mbedtls_pk_info_t mbedtls_ed25519_info = { //new_impl
+    MBEDTLS_PK_ED25519,
+    "ED25519",
+    ed25519_get_bitlen,
+    ed25519_can_do,
+    ed25519_verify_wrap,
+    ed25519_sign_wrap,
+    ed25519_decrypt_wrap,
+    ed25519_encrypt_wrap,
+    ed25519_check_pair_wrap,
+    ed25519_alloc_wrap,
+    ed25519_free_wrap,
+};
+
 const mbedtls_pk_info_t mbedtls_rsa_info = {
     MBEDTLS_PK_RSA,
     "RSA",
diff --git a/library/pk_wrap.h b/library/pk_wrap.h
index 89bce40eb..f05c49268 100644
--- a/library/pk_wrap.h
+++ b/library/pk_wrap.h
@@ -133,6 +133,8 @@ extern const mbedtls_pk_info_t mbedtls_ecdsa_info;
 extern const mbedtls_pk_info_t mbedtls_rsa_alt_info;
 #endif
 
+extern const mbedtls_pk_info_t mbedtls_ed25519_info;
+ 
 #if defined(MBEDTLS_USE_PSA_CRYPTO)
 extern const mbedtls_pk_info_t mbedtls_pk_ecdsa_opaque_info;
 extern const mbedtls_pk_info_t mbedtls_pk_rsa_opaque_info;
diff --git a/library/pkparse.c b/library/pkparse.c
index 800e352da..923d2634b 100644
--- a/library/pkparse.c
+++ b/library/pkparse.c
@@ -58,6 +58,8 @@
 
 #include "mbedtls/platform.h"
 
+#include "keystone_ext.h"
+
 #if defined(MBEDTLS_FS_IO)
 /*
  * Load all data from a file into a given buffer.
@@ -606,6 +608,10 @@ static int pk_get_pk_alg(unsigned char **p,
         return MBEDTLS_ERR_PK_UNKNOWN_PK_ALG;
     }
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("pk_get_pk_alg - %d\n", *pk_alg);
+    #endif
+
     /*
      * No parameters with RSA (only for EC)
      */
@@ -615,6 +621,9 @@ static int pk_get_pk_alg(unsigned char **p,
         return MBEDTLS_ERR_PK_INVALID_ALG;
     }
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("pk_get_pk_alg - end\n");
+    #endif
     return 0;
 }
 
@@ -660,6 +669,11 @@ int mbedtls_pk_parse_subpubkey(unsigned char **p, const unsigned char *end,
         return ret;
     }
 
+    if(pk_alg == MBEDTLS_PK_ED25519){ // new_impl
+        ret = pk_set_ed25519pubkey(p, mbedtls_pk_ed25519(*pk));
+        // ret = pk_set_ed25519pubkey(&p, &ctx->pk_ctx );//mbedtls_pk_ed25519(*ctx));
+        *p += 32;
+    } else
 #if defined(MBEDTLS_RSA_C)
     if (pk_alg == MBEDTLS_PK_RSA) {
         ret = pk_get_rsapubkey(p, end, mbedtls_pk_rsa(*pk));
@@ -684,6 +698,10 @@ int mbedtls_pk_parse_subpubkey(unsigned char **p, const unsigned char *end,
         mbedtls_pk_free(pk);
     }
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("mbedtls_pk_parse_subpubkey - %s\n", pk->pk_info->name);
+    print_hex_string("mbedtls_pk_parse_subpubkey - pk",mbedtls_pk_ed25519(*pk)->pub_key, PUBLIC_KEY_SIZE);
+    #endif 
     return ret;
 }
 
@@ -1594,4 +1612,49 @@ int mbedtls_pk_parse_public_key(mbedtls_pk_context *ctx,
     return ret;
 }
 
+int mbedtls_pk_parse_ed25519_key(mbedtls_pk_context *ctx,
+                                const unsigned char *key, size_t keylen, int type_k) // new_impl
+{
+    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
+    unsigned char *p;
+    const mbedtls_pk_info_t *pk_info;
+    if (keylen == 0) {
+        #if MBEDTLS_DEBUG_PRINTS
+        mbedtls_printf("PK - parse pk: err 1\n");
+        #endif
+        return MBEDTLS_ERR_PK_KEY_INVALID_FORMAT;
+    }
+
+    if ((pk_info = mbedtls_pk_info_from_type(MBEDTLS_PK_ED25519)) == NULL) {
+        #if MBEDTLS_DEBUG_PRINTS
+        mbedtls_printf("PK - parse pk: err 2\n");
+        #endif
+        return MBEDTLS_ERR_PK_UNKNOWN_PK_ALG;
+    }
+
+    if(ctx->pk_info != NULL && ctx->pk_info != pk_info) {
+        return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
+    }
+
+    if (ctx->pk_info == NULL && (ret = mbedtls_pk_setup(ctx, pk_info)) != 0) {
+        #if MBEDTLS_DEBUG_PRINTS
+        mbedtls_printf("PK - parse pk: err 3\n");
+        #endif
+        return ret;
+    }
+
+    p = (unsigned char *)key;
+
+    if (type_k == 0) {
+        pk_set_ed25519pubkey(&p, mbedtls_pk_ed25519(*ctx));
+        /*for(int i = 0; i < 32; i++){
+            ctx->pk_ctx->pub_key[i] = p[i];
+        }
+        ctx->pk_ctx->len = 32;*/
+    }
+    else
+        pk_set_ed25519privkey(&p, mbedtls_pk_ed25519(*ctx));
+    return 0;
+}
+
 #endif /* MBEDTLS_PK_PARSE_C */
diff --git a/library/pkwrite.c b/library/pkwrite.c
index 3c1a40809..441030789 100644
--- a/library/pkwrite.c
+++ b/library/pkwrite.c
@@ -175,6 +175,9 @@ int mbedtls_pk_write_pubkey(unsigned char **p, unsigned char *start,
     int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
     size_t len = 0;
 
+    if (mbedtls_pk_get_type(key) == MBEDTLS_PK_ED25519) {
+        MBEDTLS_ASN1_CHK_ADD(len, pk_write_ed25519_pubkey(p, start, mbedtls_pk_ed25519(*key)));
+    } else
 #if defined(MBEDTLS_RSA_C)
     if (mbedtls_pk_get_type(key) == MBEDTLS_PK_RSA) {
         MBEDTLS_ASN1_CHK_ADD(len, pk_write_rsa_pubkey(p, start, mbedtls_pk_rsa(*key)));
@@ -206,6 +209,11 @@ int mbedtls_pk_write_pubkey(unsigned char **p, unsigned char *start,
 #endif /* MBEDTLS_USE_PSA_CRYPTO */
     return MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE;
 
+
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("mbedtls_pk_write_pubkey - len = %d\n", len);
+    #endif
+
     return (int) len;
 }
 
@@ -296,6 +304,10 @@ int mbedtls_pk_write_pubkey_der(const mbedtls_pk_context *key, unsigned char *bu
         return ret;
     }
 
+    #if MBEDTLS_DEBUG_PRINTS
+    print_hex_string("mbedtls_pk_write_pubkey_der - oid", oid, oid_len);
+    #endif
+
     MBEDTLS_ASN1_CHK_ADD(len, mbedtls_asn1_write_algorithm_identifier(&c, buf, oid, oid_len,
                                                                       par_len));
 
@@ -303,6 +315,9 @@ int mbedtls_pk_write_pubkey_der(const mbedtls_pk_context *key, unsigned char *bu
     MBEDTLS_ASN1_CHK_ADD(len, mbedtls_asn1_write_tag(&c, buf, MBEDTLS_ASN1_CONSTRUCTED |
                                                      MBEDTLS_ASN1_SEQUENCE));
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("mbedtls_pk_write_pubkey_der - len = %d\n", len);
+    #endif
     return (int) len;
 }
 
diff --git a/library/platform.c b/library/platform.c
index b15b7b29a..0206be4ff 100644
--- a/library/platform.c
+++ b/library/platform.c
@@ -411,4 +411,82 @@ void mbedtls_platform_teardown(mbedtls_platform_context *ctx)
 }
 #endif /* MBEDTLS_PLATFORM_SETUP_TEARDOWN_ALT */
 
+int atoi(const char *nptr)
+{
+    int val = 0;
+    int i = 0;
+    while(nptr[i]!='\0'){
+        if(nptr[i]<'0'||nptr[i]>'9')
+            return 0;
+        val *= 10;
+        val += (int) nptr[i] - 48;
+        i++;
+    }
+    return val;
+}
+
+static unsigned long int next = 1;
+
+int rand(void)
+{  
+    // RAND_MAX assumed to be 32767
+    next = next * 1103515245 + 12345;
+    return (unsigned int)(next/65536) % 32768;
+}
+
+void srand(unsigned int seed)
+{
+    next = seed;
+}
+
+int strcmp(const char *string1, const char *string2)
+{
+    while(*string1 && (*string1 == *string2))
+    {
+        string1++;
+        string2++;
+    }
+    return *(const unsigned char*)string1 - *(const unsigned char*)string2;
+}
+
+char *strchr(const char *str, int c)
+{
+    char ch;
+
+    ch = c;
+    for (;; ++str) {
+        if (*str == ch)
+            return ((char *)str);
+        if (*str == '\0')
+            return (NULL);
+    }
+    /* NOTREACHED */
+}
+
+char *strstr(const char *str, const char *strSearch)
+{
+    char *a, *b;
+
+    b = (char*) strSearch;
+    if (*b == 0) {
+	    return (char*) str;
+    }
+    for ( ; *str != 0; str += 1) {
+        if (*str != *b) {
+            continue;
+        }
+        a = (char*) str;
+        while (1) {
+            if (*b == 0) {
+                return (char*) str;
+            }
+            if (*a++ != *b++) {
+                break;
+            }
+        }
+        b = (char*) strSearch;
+    }
+    return NULL;
+}
+
 #endif /* MBEDTLS_PLATFORM_C */
diff --git a/library/platform_util.c b/library/platform_util.c
index e903f8ed3..a5acd891d 100644
--- a/library/platform_util.c
+++ b/library/platform_util.c
@@ -51,9 +51,9 @@
 
 // Detect platforms known to support explicit_bzero()
 #if defined(__GLIBC__) && (__GLIBC__ >= 2) && (__GLIBC_MINOR__ >= 25)
-#define MBEDTLS_PLATFORM_HAS_EXPLICIT_BZERO 1
+//#define MBEDTLS_PLATFORM_HAS_EXPLICIT_BZERO 1
 #elif (defined(__FreeBSD__) && (__FreeBSD_version >= 1100037)) || defined(__OpenBSD__)
-#define MBEDTLS_PLATFORM_HAS_EXPLICIT_BZERO 1
+//#define MBEDTLS_PLATFORM_HAS_EXPLICIT_BZERO 1
 #endif
 
 #if !defined(MBEDTLS_PLATFORM_ZEROIZE_ALT)
@@ -129,6 +129,10 @@ void mbedtls_platform_zeroize(void *buf, size_t len)
 }
 #endif /* MBEDTLS_PLATFORM_ZEROIZE_ALT */
 
+void mbedtls_platform_zeroize(void *buf, size_t len){
+    memset(buf, 0x00, len);
+}
+
 #if defined(MBEDTLS_HAVE_TIME_DATE) && !defined(MBEDTLS_PLATFORM_GMTIME_R_ALT)
 #include <time.h>
 #if !defined(_WIN32) && (defined(unix) || \
diff --git a/library/x509.c b/library/x509.c
index c9524c958..99d202849 100644
--- a/library/x509.c
+++ b/library/x509.c
@@ -91,6 +91,10 @@ int mbedtls_x509_get_serial(unsigned char **p, const unsigned char *end,
     serial->p = *p;
     *p += serial->len;
 
+    #if MBEDTLS_DEBUG_PRINTS
+    print_hex_string("mbedtls_x509_get_serial - serial", serial->p, serial->len);
+    mbedtls_printf("mbedtls_x509_get_serial - serial_tag = %02x\n", serial->tag);
+    #endif
     return 0;
 }
 
@@ -124,6 +128,12 @@ int mbedtls_x509_get_alg(unsigned char **p, const unsigned char *end,
         return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_ALG, ret);
     }
 
+    #if MBEDTLS_DEBUG_PRINTS
+    print_hex_string("mbedtls_x509_get_alg - alg", alg->p, alg->len);
+    mbedtls_printf("mbedtls_x509_get_alg - alg_tag = %02x\n", alg->tag);
+    print_hex_string("mbedtls_x509_get_alg - params", params->p, params->len);
+    mbedtls_printf("mbedtls_x509_get_alg - params_tag = %02x\n", params->tag);
+    #endif
     return 0;
 }
 
@@ -466,6 +476,14 @@ static int x509_get_attr_type_value(unsigned char **p,
 
     cur->next = NULL;
 
+    #if MBEDTLS_DEBUG_PRINTS
+    print_hex_string("x509_get_attr_type_value - cur->oid", cur->oid.p, cur->oid.len);
+    mbedtls_printf("x509_get_attr_type_value - cur->oid_tag = %02x\n", cur->oid.tag);
+    print_hex_string("x509_get_attr_type_value - cur->val", cur->val.p, cur->val.len);
+    mbedtls_printf("x509_get_attr_type_value - cur->val = %02x\n", cur->val.tag);
+    mbedtls_printf("x509_get_attr_type_value - cur->val_next = %p\n", cur->next);
+    #endif
+
     return 0;
 }
 
@@ -537,6 +555,9 @@ int mbedtls_x509_get_name(unsigned char **p, const unsigned char *end,
                 goto error;
             }
 
+            #if MBEDTLS_DEBUG_PRINTS
+            mbedtls_printf("mbedtls_x509_get_name - calloc: %lu\n", sizeof(mbedtls_x509_name));
+            #endif
             cur = cur->next;
         }
 
@@ -544,6 +565,13 @@ int mbedtls_x509_get_name(unsigned char **p, const unsigned char *end,
          * continue until end of SEQUENCE is reached
          */
         if (*p == end) {
+            #if MBEDTLS_DEBUG_PRINTS
+            print_hex_string("mbedtls_x509_get_name - cur->oid", cur->oid.p, cur->oid.len);
+            mbedtls_printf("mbedtls_x509_get_name - cur->oid_tag = %02x\n", cur->oid.tag);
+            print_hex_string("mbedtls_x509_get_name - cur->val", cur->val.p, cur->val.len);
+            mbedtls_printf("mbedtls_x509_get_name - cur->val = %02x\n", cur->val.tag);
+            mbedtls_printf("mbedtls_x509_get_name - cur->val_next = %p\n", cur->next);
+            #endif
             return 0;
         }
 
@@ -554,6 +582,9 @@ int mbedtls_x509_get_name(unsigned char **p, const unsigned char *end,
             goto error;
         }
 
+        #if MBEDTLS_DEBUG_PRINTS
+        mbedtls_printf("mbedtls_x509_get_name - calloc: %lu\n", sizeof(mbedtls_x509_name));
+        #endif
         cur = cur->next;
     }
 
@@ -578,6 +609,9 @@ static int x509_parse_int(unsigned char **p, size_t n, int *res)
         *res += (*(*p)++ - '0');
     }
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("x509_parse_int - int: %d\n", *res);
+    #endif
     return 0;
 }
 
@@ -675,6 +709,10 @@ static int x509_parse_time(unsigned char **p, size_t len, size_t yearlen,
 
     CHECK(x509_date_is_valid(tm));
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("x509_parse_time - tm\n- year: %d, mon: %d, day: %d\n- hour: %d, min: %d, sec: %d\n", 
+        tm->year, tm->mon, tm->day, tm->hour, tm->min, tm->sec);
+    #endif
     return 0;
 }
 
@@ -739,6 +777,10 @@ int mbedtls_x509_get_sig(unsigned char **p, const unsigned char *end, mbedtls_x5
 
     *p += len;
 
+    #if MBEDTLS_DEBUG_PRINTS
+    print_hex_string("mbedtls_x509_get_sig - sig", sig->p, sig->len);
+    mbedtls_printf("mbedtls_x509_get_sig - sig_tag = %02x\n", sig->tag);
+    #endif
     return 0;
 }
 
@@ -788,6 +830,9 @@ int mbedtls_x509_get_sig_alg(const mbedtls_x509_buf *sig_oid, const mbedtls_x509
         }
     }
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("mbedtls_x509_get_sig_alg\n");
+    #endif
     return 0;
 }
 
@@ -827,6 +872,10 @@ int mbedtls_x509_get_ext(unsigned char **p, const unsigned char *end,
                                  MBEDTLS_ERR_ASN1_LENGTH_MISMATCH);
     }
 
+    #if MBEDTLS_DEBUG_PRINTS
+    print_hex_string("mbedtls_x509_get_ext - ext", ext->p, ext->len);
+    mbedtls_printf("mbedtls_x509_get_ext - ext_tag = %02x\n", ext->tag);
+    #endif
     return 0;
 }
 
@@ -1297,6 +1346,10 @@ int mbedtls_x509_get_subject_alt_name(unsigned char **p,
                                          MBEDTLS_ERR_ASN1_ALLOC_FAILED);
             }
 
+            #if MBEDTLS_DEBUG_PRINTS
+            mbedtls_printf("mbedtls_x509_get_subject_alt_name - calloc: %lu\n", sizeof(mbedtls_asn1_sequence));
+            #endif
+
             cur = cur->next;
         }
 
diff --git a/library/x509_create.c b/library/x509_create.c
index 50db95688..d279ece3d 100644
--- a/library/x509_create.c
+++ b/library/x509_create.c
@@ -134,6 +134,9 @@ int mbedtls_x509_string_to_names(mbedtls_asn1_named_data **head, const char *nam
     char data[MBEDTLS_X509_MAX_DN_NAME_SIZE];
     char *d = data;
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("mbedtls_x509_string_to_names - name: %s\n", name);
+    #endif
     /* Clear existing chain if present */
     mbedtls_asn1_free_named_data_list(head);
 
@@ -171,6 +174,9 @@ int mbedtls_x509_string_to_names(mbedtls_asn1_named_data **head, const char *nam
             // set tagType
             cur->val.tag = attr_descr->default_tag;
 
+            #if MBEDTLS_DEBUG_PRINTS
+            mbedtls_printf("stored:\n- oid: %s\n- oid_len: %d\n- data: %s\n- data_len: %d\n", cur->oid.p, cur->oid.len, cur->val.p, cur->val.len);
+            #endif
             while (c < end && *(c + 1) == ' ') {
                 c++;
             }
@@ -258,6 +264,9 @@ static int x509_write_name(unsigned char **p,
                                                      MBEDTLS_ASN1_CONSTRUCTED |
                                                      MBEDTLS_ASN1_SET));
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("x509_write_name - len = %d\n", len);
+    #endif
     return (int) len;
 }
 
@@ -277,6 +286,9 @@ int mbedtls_x509_write_names(unsigned char **p, unsigned char *start,
     MBEDTLS_ASN1_CHK_ADD(len, mbedtls_asn1_write_tag(p, start, MBEDTLS_ASN1_CONSTRUCTED |
                                                      MBEDTLS_ASN1_SEQUENCE));
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("mbedtls_x509_write_names - len = %d\n", len);
+    #endif
     return (int) len;
 }
 
@@ -310,6 +322,9 @@ int mbedtls_x509_write_sig(unsigned char **p, unsigned char *start,
     MBEDTLS_ASN1_CHK_ADD(len, mbedtls_asn1_write_algorithm_identifier(p, start, oid,
                                                                       oid_len, 0));
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("mbedtls_x509_write_sig - len = %d\n", len);
+    #endif
     return (int) len;
 }
 
@@ -337,6 +352,9 @@ static int x509_write_extension(unsigned char **p, unsigned char *start,
     MBEDTLS_ASN1_CHK_ADD(len, mbedtls_asn1_write_tag(p, start, MBEDTLS_ASN1_CONSTRUCTED |
                                                      MBEDTLS_ASN1_SEQUENCE));
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("x509_write_extension - len = %d\n", len);
+    #endif
     return (int) len;
 }
 
@@ -359,9 +377,15 @@ int mbedtls_x509_write_extensions(unsigned char **p, unsigned char *start,
 
     while (cur_ext != NULL) {
         MBEDTLS_ASN1_CHK_ADD(len, x509_write_extension(p, start, cur_ext));
+        #if MBEDTLS_DEBUG_PRINTS
+        print_mbedtls_asn1_named_data("mbedtls_x509_write_extensions", *cur_ext);
+        #endif
         cur_ext = cur_ext->next;
     }
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("mbedtls_x509_write_extensions - len = %d\n", len);
+    #endif
     return (int) len;
 }
 
diff --git a/library/x509_crt.c b/library/x509_crt.c
index faf862364..15440da86 100644
--- a/library/x509_crt.c
+++ b/library/x509_crt.c
@@ -162,6 +162,15 @@ const mbedtls_x509_crt_profile mbedtls_x509_crt_profile_suiteb =
     0,
 };
 
+// new_impl: Profile for usage in Keystone
+const mbedtls_x509_crt_profile mbedtls_x509_crt_profile_keystone =
+{
+    MBEDTLS_X509_ID_FLAG(MBEDTLS_MD_KEYSTONE_SHA3),
+    MBEDTLS_X509_ID_FLAG(MBEDTLS_PK_ED25519),
+    0,
+    2048, // not supported
+};
+
 /*
  * Empty / all-forbidden profile
  */
@@ -218,6 +227,10 @@ static int x509_profile_check_key(const mbedtls_x509_crt_profile *profile,
 {
     const mbedtls_pk_type_t pk_alg = mbedtls_pk_get_type(pk);
 
+    if(pk_alg == MBEDTLS_PK_ED25519){
+        return x509_profile_check_pk_alg(profile, pk_alg);
+    }
+
 #if defined(MBEDTLS_RSA_C)
     if (pk_alg == MBEDTLS_PK_RSA || pk_alg == MBEDTLS_PK_RSASSA_PSS) {
         if (mbedtls_pk_get_bitlen(pk) >= profile->rsa_min_bitlen) {
@@ -428,6 +441,9 @@ static int x509_get_version(unsigned char **p,
                                  MBEDTLS_ERR_ASN1_LENGTH_MISMATCH);
     }
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("x509_get_version - int = %d\n", *ver);
+    #endif
     return 0;
 }
 
@@ -464,6 +480,12 @@ static int x509_get_dates(unsigned char **p,
                                  MBEDTLS_ERR_ASN1_LENGTH_MISMATCH);
     }
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("x509_get_dates - from\n- year: %d, mon: %d, day: %d\n- hour: %d, min: %d, sec: %d\n", 
+        from->year, from->mon, from->day, from->hour, from->min, from->sec);
+    mbedtls_printf("x509_get_dates - to\n- year: %d, mon: %d, day: %d\n- hour: %d, min: %d, sec: %d\n", 
+        to->year, to->mon, to->day, to->hour, to->min, to->sec);
+    #endif
     return 0;
 }
 
@@ -495,6 +517,10 @@ static int x509_get_uid(unsigned char **p,
     uid->p = *p;
     *p += uid->len;
 
+    #if MBEDTLS_DEBUG_PRINTS
+    print_hex_string("x509_get_uid - uid", uid->p, uid->len);
+    mbedtls_printf("x509_get_uid - uid_tag = %02x\n", uid->tag);
+    #endif
     return 0;
 }
 
@@ -766,7 +792,14 @@ static int x509_get_crt_ext(unsigned char **p,
 {
     int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
     size_t len;
-    unsigned char *end_ext_data, *start_ext_octet, *end_ext_octet;
+    unsigned char *end_ext_data /**start_ext_octet*/, *end_ext_octet;
+
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("x509_get_crt_ext\n");
+    #endif
+
+    // unsigned char oid_ext1[] = {0xff, 0x20, 0xff};
+    unsigned char oid_ext2[] = {0x55, 0x1d, 0x13};
 
     if (*p == end) {
         return 0;
@@ -786,7 +819,7 @@ static int x509_get_crt_ext(unsigned char **p,
          */
         mbedtls_x509_buf extn_oid = { 0, 0, NULL };
         int is_critical = 0; /* DEFAULT FALSE */
-        int ext_type = 0;
+        // int ext_type = 0;
 
         if ((ret = mbedtls_asn1_get_tag(p, end, &len,
                                         MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE)) != 0) {
@@ -817,128 +850,153 @@ static int x509_get_crt_ext(unsigned char **p,
             return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
         }
 
-        start_ext_octet = *p;
+        // start_ext_octet = *p;
         end_ext_octet = *p + len;
 
         if (end_ext_octet != end_ext_data) {
             return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS,
                                      MBEDTLS_ERR_ASN1_LENGTH_MISMATCH);
         }
-
-        /*
-         * Detect supported extensions
-         */
-        ret = mbedtls_oid_get_x509_ext_type(&extn_oid, &ext_type);
-
-        if (ret != 0) {
-            /* Give the callback (if any) a chance to handle the extension */
-            if (cb != NULL) {
-                ret = cb(p_ctx, crt, &extn_oid, is_critical, *p, end_ext_octet);
-                if (ret != 0 && is_critical) {
-                    return ret;
+        
+        if(mbedtls_memcmp(extn_oid.p, oid_ext2, 3)== 0){
+            //crt->ca_istrue = 1;
+            //unsigned char app = **p;
+            //crt->max_pathlen = (int) app;
+            //crt->max_pathlen = (*p);
+            //*p +=1;
+            if ((ret = x509_get_basic_constraints(p, end_ext_octet,
+                                                      &crt->ca_istrue, &crt->max_pathlen)) != 0) {
+                  
+                   return ret;
                 }
-                *p = end_ext_octet;
-                continue;
-            }
-
-            /* No parser found, skip extension */
-            *p = end_ext_octet;
-
-            if (is_critical) {
-                /* Data is marked as critical: fail */
-                return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS,
-                                         MBEDTLS_ERR_ASN1_UNEXPECTED_TAG);
-            }
-            continue;
         }
-
-        /* Forbid repeated extensions */
-        if ((crt->ext_types & ext_type) != 0) {
-            return MBEDTLS_ERR_X509_INVALID_EXTENSIONS;
+        else{
+            crt ->hash.p = *p;
+            crt ->hash.len = 64;
+            *p += 64;
         }
 
-        crt->ext_types |= ext_type;
 
-        switch (ext_type) {
-            case MBEDTLS_X509_EXT_BASIC_CONSTRAINTS:
-                /* Parse basic constraints */
-                if ((ret = x509_get_basic_constraints(p, end_ext_octet,
-                                                      &crt->ca_istrue, &crt->max_pathlen)) != 0) {
-                    return ret;
-                }
-                break;
+        // mbedtls_memcpy(crt->hash.p_arr,*p, 64);
 
-            case MBEDTLS_X509_EXT_KEY_USAGE:
-                /* Parse key usage */
-                if ((ret = mbedtls_x509_get_key_usage(p, end_ext_octet,
-                                                      &crt->key_usage)) != 0) {
-                    return ret;
-                }
-                break;
+        // crt->hash.p = *p;
+        // crt->hash.len = 64;
+        // *p += 64;
 
-            case MBEDTLS_X509_EXT_EXTENDED_KEY_USAGE:
-                /* Parse extended key usage */
-                if ((ret = x509_get_ext_key_usage(p, end_ext_octet,
-                                                  &crt->ext_key_usage)) != 0) {
-                    return ret;
-                }
-                break;
+        /*
+         * Detect supported extensions
+         */
+        // ret = mbedtls_oid_get_x509_ext_type(&extn_oid, &ext_type);
+
+        // if (ret != 0) {
+        /* Give the callback (if any) a chance to handle the extension */
+        //   if (cb != NULL) {
+        //     ret = cb(p_ctx, crt, &extn_oid, is_critical, *p, end_ext_octet);
+        //   if (ret != 0 && is_critical) {
+        //     return ret;
+        //}
+        //*p = end_ext_octet;
+        // continue;
+        //}
+
+        /* No parser found, skip extension */
+        //*p = end_ext_octet;
+
+        // if (is_critical) {
+        /* Data is marked as critical: fail */
+        //  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS,
+        // MBEDTLS_ERR_ASN1_UNEXPECTED_TAG);
+        //}
+        // continue;
+        //}
 
-            case MBEDTLS_X509_EXT_SUBJECT_ALT_NAME:
-                /* Parse subject alt name */
-                if ((ret = mbedtls_x509_get_subject_alt_name(p, end_ext_octet,
-                                                             &crt->subject_alt_names)) != 0) {
-                    return ret;
-                }
-                break;
+        /* Forbid repeated extensions */
+        // if ((crt->ext_types & ext_type) != 0) {
+        //   return MBEDTLS_ERR_X509_INVALID_EXTENSIONS;
+        //}
 
-            case MBEDTLS_X509_EXT_NS_CERT_TYPE:
-                /* Parse netscape certificate type */
-                if ((ret = mbedtls_x509_get_ns_cert_type(p, end_ext_octet,
-                                                         &crt->ns_cert_type)) != 0) {
-                    return ret;
-                }
-                break;
+        // crt->ext_types |= ext_type;
 
-            case MBEDTLS_OID_X509_EXT_CERTIFICATE_POLICIES:
-                /* Parse certificate policies type */
-                if ((ret = x509_get_certificate_policies(p, end_ext_octet,
-                                                         &crt->certificate_policies)) != 0) {
-                    /* Give the callback (if any) a chance to handle the extension
-                     * if it contains unsupported policies */
-                    if (ret == MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE && cb != NULL &&
-                        cb(p_ctx, crt, &extn_oid, is_critical,
-                           start_ext_octet, end_ext_octet) == 0) {
-                        break;
-                    }
-
-                    if (is_critical) {
-                        return ret;
-                    } else
-                    /*
-                     * If MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE is returned, then we
-                     * cannot interpret or enforce the policy. However, it is up to
-                     * the user to choose how to enforce the policies,
-                     * unless the extension is critical.
-                     */
-                    if (ret != MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE) {
-                        return ret;
-                    }
+        /**
+         * Le extensions non vengono parsate come un array di tali, ma vanno direttamente a fillare il
+         * campo corrrispettivo nella struttura
+         *
+         */
+        // switch (ext_type) {
+        /*
+        case MBEDTLS_X509_EXT_BASIC_CONSTRAINTS:
+            // Parse basic constraints
+            if ((ret = x509_get_basic_constraints(p, end_ext_octet,
+                                                  &crt->ca_istrue, &crt->max_pathlen)) != 0) {
+                return ret;
+            }
+            break;
+        case MBEDTLS_X509_EXT_KEY_USAGE:
+            // Parse key usage
+            if ((ret = mbedtls_x509_get_key_usage(p, end_ext_octet,
+                                                  &crt->key_usage)) != 0) {
+                return ret;
+            }
+            break;
+        case MBEDTLS_X509_EXT_EXTENDED_KEY_USAGE:
+            // Parse extended key usage
+            if ((ret = x509_get_ext_key_usage(p, end_ext_octet,
+                                              &crt->ext_key_usage)) != 0) {
+                return ret;
+            }
+            break;
+        case MBEDTLS_X509_EXT_SUBJECT_ALT_NAME:
+            // Parse subject alt name
+            if ((ret = mbedtls_x509_get_subject_alt_name(p, end_ext_octet,
+                                                         &crt->subject_alt_names)) != 0) {
+                return ret;
+            }
+            break;
+        case MBEDTLS_X509_EXT_NS_CERT_TYPE:
+            // Parse netscape certificate type
+            if ((ret = mbedtls_x509_get_ns_cert_type(p, end_ext_octet,
+                                                     &crt->ns_cert_type)) != 0) {
+                return ret;
+            }
+            break;
+        case MBEDTLS_OID_X509_EXT_CERTIFICATE_POLICIES:
+            // Parse certificate policies type
+            if ((ret = x509_get_certificate_policies(p, end_ext_octet,
+                                                     &crt->certificate_policies)) != 0) {
+                //Give the callback (if any) a chance to handle the extension
+                 // if it contains unsupported policies
+                if (ret == MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE && cb != NULL &&
+                    cb(p_ctx, crt, &extn_oid, is_critical,
+                       start_ext_octet, end_ext_octet) == 0) {
+                    break;
                 }
-                break;
-
-            default:
-                /*
-                 * If this is a non-critical extension, which the oid layer
-                 * supports, but there isn't an x509 parser for it,
-                 * skip the extension.
-                 */
                 if (is_critical) {
-                    return MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE;
-                } else {
-                    *p = end_ext_octet;
+                    return ret;
+                } else
+                //
+                 // If MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE is returned, then we
+                 // cannot interpret or enforce the policy. However, it is up to
+                 // the user to choose how to enforce the policies,
+                 // unless the extension is critical.
+                 //
+                if (ret != MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE) {
+                    return ret;
                 }
-        }
+            }
+            break;
+        */
+        // default:
+        /*
+         * If this is a non-critical extension, which the oid layer
+         * supports, but there isn't an x509 parser for it,
+         * skip the extension.
+         */
+        //  if (is_critical) {
+        //    return MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE;
+        //} else {
+        //  *p = end_ext_octet;
+        //}
+        //}
     }
 
     if (*p != end) {
@@ -980,6 +1038,9 @@ static int x509_crt_parse_der_core(mbedtls_x509_crt *crt,
     len = buflen;
     end = p + len;
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("x509_crt_parse_der_core - certificate\n");
+    #endif
     /*
      * Certificate  ::=  SEQUENCE  {
      *      tbsCertificate       TBSCertificate,
@@ -1001,6 +1062,9 @@ static int x509_crt_parse_der_core(mbedtls_x509_crt *crt,
             return MBEDTLS_ERR_X509_ALLOC_FAILED;
         }
 
+        #if MBEDTLS_DEBUG_PRINTS
+        mbedtls_printf("x509_crt_parse_der_core - calloc: %lu\n", crt->raw.len);
+        #endif
         memcpy(crt->raw.p, buf, crt->raw.len);
         crt->own_buffer = 1;
 
@@ -1011,6 +1075,9 @@ static int x509_crt_parse_der_core(mbedtls_x509_crt *crt,
         crt->own_buffer = 0;
     }
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("x509_crt_parse_der_core - tbs cert\n");
+    #endif
     /*
      * TBSCertificate  ::=  SEQUENCE  {
      */
@@ -1025,6 +1092,9 @@ static int x509_crt_parse_der_core(mbedtls_x509_crt *crt,
     end = p + len;
     crt->tbs.len = end - crt->tbs.p;
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("x509_crt_parse_der_core - version\n");
+    #endif
     /*
      * Version  ::=  INTEGER  {  v1(0), v2(1), v3(2)  }
      *
@@ -1054,6 +1124,9 @@ static int x509_crt_parse_der_core(mbedtls_x509_crt *crt,
         return ret;
     }
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("x509_crt_parse_der_core - issuer\n");
+    #endif
     /*
      * issuer               Name
      */
@@ -1072,6 +1145,9 @@ static int x509_crt_parse_der_core(mbedtls_x509_crt *crt,
 
     crt->issuer_raw.len = p - crt->issuer_raw.p;
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("x509_crt_parse_der_core - validity\n");
+    #endif
     /*
      * Validity ::= SEQUENCE {
      *      notBefore      Time,
@@ -1084,6 +1160,9 @@ static int x509_crt_parse_der_core(mbedtls_x509_crt *crt,
         return ret;
     }
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("x509_crt_parse_der_core - subject\n");
+    #endif
     /*
      * subject              Name
      */
@@ -1102,6 +1181,9 @@ static int x509_crt_parse_der_core(mbedtls_x509_crt *crt,
 
     crt->subject_raw.len = p - crt->subject_raw.p;
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("x509_crt_parse_der_core - subPKInfo\n");
+    #endif
     /*
      * SubjectPublicKeyInfo
      */
@@ -1112,6 +1194,9 @@ static int x509_crt_parse_der_core(mbedtls_x509_crt *crt,
     }
     crt->pk_raw.len = p - crt->pk_raw.p;
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("x509_crt_parse_der_core - uid and exts\n");
+    #endif
     /*
      *  issuerUniqueID  [1]  IMPLICIT UniqueIdentifier OPTIONAL,
      *                       -- If present, version shall be v2 or v3
@@ -1152,6 +1237,9 @@ static int x509_crt_parse_der_core(mbedtls_x509_crt *crt,
 
     end = crt_end;
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("x509_crt_parse_der_core - signature\n");
+    #endif
     /*
      *  }
      *  -- end of TBSCertificate
@@ -1224,6 +1312,9 @@ static int mbedtls_x509_crt_parse_der_internal(mbedtls_x509_crt *chain,
             return MBEDTLS_ERR_X509_ALLOC_FAILED;
         }
 
+        #if MBEDTLS_DEBUG_PRINTS
+        mbedtls_printf("mbedtls_x509_crt_parse_der_internal - calloc: %lu\n", sizeof(mbedtls_x509_crt));
+        #endif
         prev = crt;
         mbedtls_x509_crt_init(crt->next);
         crt = crt->next;
@@ -1237,6 +1328,9 @@ static int mbedtls_x509_crt_parse_der_internal(mbedtls_x509_crt *chain,
 
         if (crt != chain) {
             mbedtls_free(crt);
+            #if MBEDTLS_DEBUG_PRINTS
+            mbedtls_printf("mbedtls_x509_crt_parse_der_internal - free: %lu\n", sizeof(mbedtls_x509_crt));
+            #endif
         }
 
         return ret;
@@ -1989,6 +2083,9 @@ static int x509_crt_check_signature(const mbedtls_x509_crt *child,
 
     /* Note: hash errors can happen only after an internal error */
     if (mbedtls_md(md_info, child->tbs.p, child->tbs.len, hash) != 0) {
+        #if MBEDTLS_DEBUG_PRINTS
+        mbedtls_printf("x509_crt_check_signature - exit 1\n");
+        #endif
         return -1;
     }
 #else
@@ -2008,6 +2105,9 @@ static int x509_crt_check_signature(const mbedtls_x509_crt *child,
 #endif /* MBEDTLS_USE_PSA_CRYPTO */
     /* Skip expensive computation on obvious mismatch */
     if (!mbedtls_pk_can_do(&parent->pk, child->sig_pk)) {
+        #if MBEDTLS_DEBUG_PRINTS
+        mbedtls_printf("x509_crt_check_signature - exit 2\n");
+        #endif
         return -1;
     }
 
@@ -2040,26 +2140,46 @@ static int x509_crt_check_parent(const mbedtls_x509_crt *child,
 
     /* Parent must be the issuer */
     if (x509_name_cmp(&child->issuer, &parent->subject) != 0) {
+        #if MBEDTLS_DEBUG_PRINTS
+        mbedtls_printf("x509_crt_check_parent - exit 1\n");
+        #endif
         return -1;
     }
 
     /* Parent must have the basicConstraints CA bit set as a general rule */
     need_ca_bit = 1;
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("x509_crt_check_parent - top=%d, version=%d\n", top, parent->version);
+    #endif
+
     /* Exception: v1/v2 certificates that are locally trusted. */
     if (top && parent->version < 3) {
         need_ca_bit = 0;
     }
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("x509_crt_check_parent - need_ca_bit=%d, ca_istrue=%d\n", need_ca_bit, parent->ca_istrue);
+    #endif
+
     if (need_ca_bit && !parent->ca_istrue) {
+        #if MBEDTLS_DEBUG_PRINTS
+        mbedtls_printf("x509_crt_check_parent - exit 2\n");
+        #endif
         return -1;
     }
 
     if (need_ca_bit &&
         mbedtls_x509_crt_check_key_usage(parent, MBEDTLS_X509_KU_KEY_CERT_SIGN) != 0) {
+        #if MBEDTLS_DEBUG_PRINTS
+        mbedtls_printf("x509_crt_check_parent - exit 3\n");
+        #endif
         return -1;
     }
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("x509_crt_check_parent - return\n");
+    #endif
     return 0;
 }
 
@@ -2138,18 +2258,35 @@ static int x509_crt_find_parent_in(
     }
 #endif
 
+#if MBEDTLS_DEBUG_PRINTS
+    int i = 0;
+#endif
+
     fallback_parent = NULL;
     fallback_signature_is_good = 0;
 
     for (parent = candidates; parent != NULL; parent = parent->next) {
+
+        #if MBEDTLS_DEBUG_PRINTS
+        mbedtls_printf("x509_crt_find_parent_in - iteration %d\n", i);
+        i++;
+        #endif
+        
+
         /* basic parenting skills (name, CA bit, key usage) */
         if (x509_crt_check_parent(child, parent, top) != 0) {
+            #if MBEDTLS_DEBUG_PRINTS
+            mbedtls_printf("x509_crt_find_parent_in - continue 1\n");
+            #endif
             continue;
         }
 
         /* +1 because stored max_pathlen is 1 higher that the actual value */
         if (parent->max_pathlen > 0 &&
             (size_t) parent->max_pathlen < 1 + path_cnt - self_cnt) {
+            #if MBEDTLS_DEBUG_PRINTS
+            mbedtls_printf("x509_crt_find_parent_in - continue 2\n");
+            #endif
             continue;
         }
 
@@ -2174,6 +2311,9 @@ check_signature:
 
         signature_is_good = ret == 0;
         if (top && !signature_is_good) {
+            #if MBEDTLS_DEBUG_PRINTS
+            mbedtls_printf("x509_crt_find_parent_in - continue 3\n");
+            #endif
             continue;
         }
 
@@ -2185,20 +2325,33 @@ check_signature:
                 fallback_signature_is_good = signature_is_good;
             }
 
+            #if MBEDTLS_DEBUG_PRINTS
+            mbedtls_printf("x509_crt_find_parent_in - continue 4\n");
+            #endif
             continue;
         }
 
         *r_parent = parent;
         *r_signature_is_good = signature_is_good;
 
+        #if MBEDTLS_DEBUG_PRINTS
+        mbedtls_printf("x509_crt_find_parent_in - break\n");
+        #endif
         break;
     }
 
     if (parent == NULL) {
         *r_parent = fallback_parent;
         *r_signature_is_good = fallback_signature_is_good;
+        #if MBEDTLS_DEBUG_PRINTS
+        mbedtls_printf("x509_crt_find_parent_in - parent is NULL\n");
+        #endif
     }
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("x509_crt_find_parent_in - return\n");    
+    #endif
+
     return 0;
 }
 
@@ -2246,10 +2399,18 @@ static int x509_crt_find_parent(
         rs_ctx->parent_is_trusted = -1;
     }
 #endif
+#if MBEDTLS_DEBUG_PRINTS
+    int i = 0;
+#endif
 
     while (1) {
         search_list = *parent_is_trusted ? trust_ca : child->next;
 
+        #if MBEDTLS_DEBUG_PRINTS
+        mbedtls_printf("x509_crt_find_parent - iteration %d\n", i);
+        i++;
+        #endif
+
         ret = x509_crt_find_parent_in(child, search_list,
                                       parent, signature_is_good,
                                       *parent_is_trusted,
@@ -2396,6 +2557,10 @@ static int x509_crt_verify_chain(
     parent_is_trusted = 0;
     child_is_trusted = 0;
 
+    #if MBEDTLS_DEBUG_PRINTS
+    int i = 0;
+    #endif
+
     while (1) {
         /* Add certificate to the verification chain */
         cur = &ver_chain->items[ver_chain->len];
@@ -2404,6 +2569,11 @@ static int x509_crt_verify_chain(
         ver_chain->len++;
         flags = &cur->flags;
 
+        #if MBEDTLS_DEBUG_PRINTS
+        mbedtls_printf("x509_crt_verify_chain - iteration %d\n", i);
+        i++;
+        #endif
+
         /* Check time-validity (all certificates) */
         if (mbedtls_x509_time_is_past(&child->valid_to)) {
             *flags |= MBEDTLS_X509_BADCERT_EXPIRED;
@@ -2413,8 +2583,18 @@ static int x509_crt_verify_chain(
             *flags |= MBEDTLS_X509_BADCERT_FUTURE;
         }
 
+        if(checkTCIValue(&child->subject, &child->hash)){
+            #if MBEDTLS_DEBUG_PRINTS
+            mbedtls_printf("x509_crt_verify_chain - failed TCI\n");
+            #endif
+            *flags |= MBEDTLS_X509_BADCERT_OTHER;
+        }
+
         /* Stop here for trusted roots (but not for trusted EE certs) */
         if (child_is_trusted) {
+            #if MBEDTLS_DEBUG_PRINTS
+            mbedtls_printf("x509_crt_verify_chain - exit 1\n");
+            #endif
             return 0;
         }
 
@@ -2430,6 +2610,9 @@ static int x509_crt_verify_chain(
         /* Special case: EE certs that are locally trusted */
         if (ver_chain->len == 1 &&
             x509_crt_check_ee_locally_trusted(child, trust_ca) == 0) {
+            #if MBEDTLS_DEBUG_PRINTS
+            mbedtls_printf("x509_crt_verify_chain - exit 2\n");
+            #endif
             return 0;
         }
 
@@ -2480,6 +2663,9 @@ find_parent:
         /* No parent? We're done here */
         if (parent == NULL) {
             *flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;
+            #if MBEDTLS_DEBUG_PRINTS
+            mbedtls_printf("x509_crt_verify_chain - exit 3\n");
+            #endif
             return 0;
         }
 
@@ -2496,6 +2682,9 @@ find_parent:
         if (!parent_is_trusted &&
             ver_chain->len > MBEDTLS_X509_MAX_INTERMEDIATE_CA) {
             /* return immediately to avoid overflow the chain array */
+            #if MBEDTLS_DEBUG_PRINTS
+            mbedtls_printf("x509_crt_verify_chain - exit 4\n");
+            #endif
             return MBEDTLS_ERR_X509_FATAL_ERROR;
         }
 
@@ -2616,6 +2805,9 @@ static int x509_crt_merge_flags_with_cb(
     for (i = ver_chain->len; i != 0; --i) {
         cur = &ver_chain->items[i-1];
         cur_flags = cur->flags;
+        #if MBEDTLS_DEBUG_PRINTS
+        mbedtls_printf("x509_crt_merge_flags_with_cb - %d - cur_flags=%u\n", i, cur_flags);
+        #endif
 
         if (NULL != f_vrfy) {
             if ((ret = f_vrfy(p_vrfy, cur->crt, (int) i-1, &cur_flags)) != 0) {
@@ -2671,6 +2863,9 @@ static int x509_crt_verify_restartable_ca_cb(mbedtls_x509_crt *crt,
 
     if (profile == NULL) {
         ret = MBEDTLS_ERR_X509_BAD_INPUT_DATA;
+        #if MBEDTLS_DEBUG_PRINTS
+        mbedtls_printf("x509_crt_verify_restartable_ca_cb - exit 1\n");
+        #endif
         goto exit;
     }
 
@@ -2679,6 +2874,10 @@ static int x509_crt_verify_restartable_ca_cb(mbedtls_x509_crt *crt,
         x509_crt_verify_name(crt, cn, &ee_flags);
     }
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("x509_crt_verify_restartable_ca_cb - 1-ee_flags=%u\n", ee_flags);
+    #endif
+
     /* Check the type and size of the key */
     pk_type = mbedtls_pk_get_type(&crt->pk);
 
@@ -2686,22 +2885,37 @@ static int x509_crt_verify_restartable_ca_cb(mbedtls_x509_crt *crt,
         ee_flags |= MBEDTLS_X509_BADCERT_BAD_PK;
     }
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("x509_crt_verify_restartable_ca_cb - 2-ee_flags=%u\n", ee_flags);
+    #endif
+
     if (x509_profile_check_key(profile, &crt->pk) != 0) {
         ee_flags |= MBEDTLS_X509_BADCERT_BAD_KEY;
     }
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("x509_crt_verify_restartable_ca_cb - 3-ee_flags=%u\n", ee_flags);
+    #endif
+
     /* Check the chain */
     ret = x509_crt_verify_chain(crt, trust_ca, ca_crl,
                                 f_ca_cb, p_ca_cb, profile,
                                 &ver_chain, rs_ctx);
 
     if (ret != 0) {
+        #if MBEDTLS_DEBUG_PRINTS
+        mbedtls_printf("x509_crt_verify_restartable_ca_cb - exit 2\n");
+        #endif
         goto exit;
     }
 
     /* Merge end-entity flags */
     ver_chain.items[0].flags |= ee_flags;
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("x509_crt_verify_restartable_ca_cb - 4-item_flags=%u\n", ver_chain.items[0].flags);
+    #endif
+
     /* Build final flags, calling callback on the way if any */
     ret = x509_crt_merge_flags_with_cb(flags, &ver_chain, f_vrfy, p_vrfy);
 
@@ -2723,15 +2937,24 @@ exit:
      * the SSL module for authmode optional, but non-zero return from the
      * callback means a fatal error so it shouldn't be ignored */
     if (ret == MBEDTLS_ERR_X509_CERT_VERIFY_FAILED) {
+        #if MBEDTLS_DEBUG_PRINTS
+        mbedtls_printf("x509_crt_verify_restartable_ca_cb - exit 3\n");
+        #endif
         ret = MBEDTLS_ERR_X509_FATAL_ERROR;
     }
 
     if (ret != 0) {
         *flags = (uint32_t) -1;
+        #if MBEDTLS_DEBUG_PRINTS
+        mbedtls_printf("x509_crt_verify_restartable_ca_cb - exit 4\n");
+        #endif
         return ret;
     }
 
     if (*flags != 0) {
+        #if MBEDTLS_DEBUG_PRINTS
+        mbedtls_printf("x509_crt_verify_restartable_ca_cb - exit 5\n");
+        #endif
         return MBEDTLS_ERR_X509_CERT_VERIFY_FAILED;
     }
 
@@ -2841,6 +3064,9 @@ void mbedtls_x509_crt_free(mbedtls_x509_crt *crt)
         if (cert_cur->raw.p != NULL && cert_cur->own_buffer) {
             mbedtls_platform_zeroize(cert_cur->raw.p, cert_cur->raw.len);
             mbedtls_free(cert_cur->raw.p);
+            #if MBEDTLS_DEBUG_PRINTS
+            mbedtls_printf("mbedtls_x509_crt_free - free: %lu\n", cert_cur->raw.len);
+            #endif
         }
 
         cert_prv = cert_cur;
@@ -2849,6 +3075,9 @@ void mbedtls_x509_crt_free(mbedtls_x509_crt *crt)
         mbedtls_platform_zeroize(cert_prv, sizeof(mbedtls_x509_crt));
         if (cert_prv != crt) {
             mbedtls_free(cert_prv);
+            #if MBEDTLS_DEBUG_PRINTS
+            mbedtls_printf("mbedtls_x509_crt_free - free: %lu\n", sizeof(mbedtls_x509_crt));
+            #endif
         }
     }
 }
diff --git a/library/x509_csr.c b/library/x509_csr.c
index cd117cbd4..2dc497cb8 100644
--- a/library/x509_csr.c
+++ b/library/x509_csr.c
@@ -43,11 +43,130 @@
 #endif
 
 #include "mbedtls/platform.h"
+#include "keystone_ext.h"
 
 #if defined(MBEDTLS_FS_IO) || defined(EFIX64) || defined(EFI32)
 #include <stdio.h>
 #endif
 
+// custom new_impl: function to retrieve nonce
+static int mbedtls_x509_get_nonce(unsigned char **p, const unsigned char *end, mbedtls_x509_buf *nonce) {
+    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
+    size_t len = 0;
+
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("mbedtls_x509_get_nonce\n");
+    #endif
+
+    if ((ret = mbedtls_asn1_get_tag(p, end, &len,
+                                        MBEDTLS_ASN1_OCTET_STRING)) != 0) {
+        return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
+    }
+
+    if (*p + len > end || len != NONCE_LEN) {
+        return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS,
+                                    MBEDTLS_ERR_ASN1_LENGTH_MISMATCH);
+    }
+
+    /* Get actual bitstring */
+    nonce->len = len;
+    nonce->p = mbedtls_calloc(NONCE_LEN, 1);
+    mbedtls_memcpy(nonce->p, *p, NONCE_LEN);
+    *p += len;
+
+    #if MBEDTLS_DEBUG_PRINTS
+    print_hex_string("mbedtls_x509_get_nonce", nonce->p, nonce->len);
+    #endif
+
+    return 0;
+}
+
+// custom new_impl: function to retrieve attestation evidence
+static int mbedtls_x509_get_attestation_proof(unsigned char **p, const unsigned char *end, mbedtls_x509_buf *attestation_proof) {
+    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
+    size_t len = 0;
+
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("mbedtls_x509_get_attestation_proof\n");
+    #endif
+
+    if ((ret = mbedtls_asn1_get_tag(p, end, &len,
+                                        MBEDTLS_ASN1_OCTET_STRING)) != 0) {
+        return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
+    }
+
+    if (*p + len > end || len != ATTESTATION_PROOF_LEN) {
+        return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS,
+                                    MBEDTLS_ERR_ASN1_LENGTH_MISMATCH);
+    }
+
+    /* Get actual bitstring */
+    attestation_proof->len = len;
+    attestation_proof->p = mbedtls_calloc(ATTESTATION_PROOF_LEN, 1);
+    mbedtls_memcpy(attestation_proof->p, *p, ATTESTATION_PROOF_LEN);
+    *p += len;
+
+    #if MBEDTLS_DEBUG_PRINTS
+    print_hex_string("mbedtls_x509_get_attestation_proof", attestation_proof->p, attestation_proof->len);
+    #endif
+
+    return 0;
+}
+
+// custom new_impl: function to parse DICE certificate
+static int get_certs(unsigned char **p, const unsigned char *end, mbedtls_x509_crt *cert_chain) {
+    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
+    size_t len;
+
+    if ((ret = mbedtls_asn1_get_tag(p, end, &len,
+                                        MBEDTLS_ASN1_OCTET_STRING)) != 0) {
+        return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
+    }
+
+    if (*p + len > end) {
+        return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS,
+                                    MBEDTLS_ERR_ASN1_LENGTH_MISMATCH);
+    }
+
+    if((ret = mbedtls_x509_crt_parse_der(cert_chain, *p, len)) != 0) {
+        return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
+    }
+
+    *p += len;
+
+    return 0;
+}
+
+// custom new_impl: function to retrieve DICE certificates
+static int mbedtls_x509_get_dice_certs(unsigned char **p, const unsigned char *end, mbedtls_x509_crt *cert_chain) {
+    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
+    size_t len;
+    unsigned char *end_ext_data;
+
+    mbedtls_x509_crt_init(cert_chain);
+    
+    if ((ret = mbedtls_asn1_get_tag(p, end, &len,
+                                        MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE)) != 0) {
+        return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
+    }
+
+    end_ext_data = *p + len;
+
+    if((ret = get_certs(p, end_ext_data, cert_chain)) != 0) {
+        return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
+    }
+
+    if((ret = get_certs(p, end_ext_data, cert_chain)) != 0) {
+        return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
+    }
+
+    if((ret = get_certs(p, end_ext_data, cert_chain)) != 0) {
+        return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
+    }
+
+    return 0;
+}
+
 /*
  *  Version  ::=  INTEGER  {  v1(0)  }
  */
@@ -79,12 +198,20 @@ static int x509_csr_parse_extensions(mbedtls_x509_csr *csr,
     size_t len;
     unsigned char *end_ext_data;
     while (*p < end) {
+        
+        #if MBEDTLS_DEBUG_PRINTS
+        mbedtls_printf("x509_csr_parse_extensions - ...\n");
+        #endif
+
         mbedtls_x509_buf extn_oid = { 0, 0, NULL };
         int ext_type = 0;
 
         /* Read sequence tag */
         if ((ret = mbedtls_asn1_get_tag(p, end, &len,
                                         MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE)) != 0) {
+            #if MBEDTLS_DEBUG_PRINTS
+            mbedtls_printf("x509_csr_parse_extensions - error 1\n");
+            #endif
             return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
         }
 
@@ -93,6 +220,9 @@ static int x509_csr_parse_extensions(mbedtls_x509_csr *csr,
         /* Get extension ID */
         if ((ret = mbedtls_asn1_get_tag(p, end_ext_data, &extn_oid.len,
                                         MBEDTLS_ASN1_OID)) != 0) {
+            #if MBEDTLS_DEBUG_PRINTS
+            mbedtls_printf("x509_csr_parse_extensions - error 2\n");
+            #endif
             return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
         }
 
@@ -103,10 +233,16 @@ static int x509_csr_parse_extensions(mbedtls_x509_csr *csr,
         /* Data should be octet string type */
         if ((ret = mbedtls_asn1_get_tag(p, end_ext_data, &len,
                                         MBEDTLS_ASN1_OCTET_STRING)) != 0) {
+            #if MBEDTLS_DEBUG_PRINTS
+            mbedtls_printf("x509_csr_parse_extensions - error 3\n");
+            #endif
             return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
         }
 
         if (*p + len != end_ext_data) {
+            #if MBEDTLS_DEBUG_PRINTS
+            mbedtls_printf("x509_csr_parse_extensions - error 4\n");
+            #endif
             return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS,
                                      MBEDTLS_ERR_ASN1_LENGTH_MISMATCH);
         }
@@ -119,6 +255,9 @@ static int x509_csr_parse_extensions(mbedtls_x509_csr *csr,
         if (ret == 0) {
             /* Forbid repeated extensions */
             if ((csr->ext_types & ext_type) != 0) {
+                #if MBEDTLS_DEBUG_PRINTS
+                mbedtls_printf("x509_csr_parse_extensions - error 5\n");
+                #endif
                 return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS,
                                          MBEDTLS_ERR_ASN1_INVALID_DATA);
             }
@@ -149,6 +288,27 @@ static int x509_csr_parse_extensions(mbedtls_x509_csr *csr,
                         return ret;
                     }
                     break;
+                case MBEDTLS_X509_EXT_NONCE: // new_impl
+                    /* Parse nonce */
+                    if((ret = mbedtls_x509_get_nonce(p, end_ext_data, 
+                                                    &csr->nonce)) != 0){
+                        return ret;
+                    }
+                    break;
+                case MBEDTLS_X509_EXT_DICE_CERTS: // new_impl
+                    /* Parse dice certs */
+                    if((ret = mbedtls_x509_get_dice_certs(p, end_ext_data, 
+                                                    &csr->cert_chain)) != 0){
+                        return ret;
+                    }
+                    break;
+                case MBEDTLS_X509_EXT_ATTESTATION_PROOF: // new_impl
+                    /* Parse attestation proof */
+                    if((ret = mbedtls_x509_get_attestation_proof(p, end_ext_data, 
+                                                                &csr->attestation_proof)) != 0){
+                        return ret;
+                    }
+                    break;
                 default:
                     break;
             }
@@ -239,7 +399,7 @@ int mbedtls_x509_csr_parse_der(mbedtls_x509_csr *csr,
     unsigned char *p, *end;
     mbedtls_x509_buf sig_params;
 
-    memset(&sig_params, 0, sizeof(mbedtls_x509_buf));
+    mbedtls_memset(&sig_params, 0, sizeof(mbedtls_x509_buf));
 
     /*
      * Check for valid input
@@ -259,7 +419,11 @@ int mbedtls_x509_csr_parse_der(mbedtls_x509_csr *csr,
         return MBEDTLS_ERR_X509_ALLOC_FAILED;
     }
 
-    memcpy(p, buf, buflen);
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("mbedtls_x509_csr_parse_der - calloc: %lu\n", len);
+    #endif
+
+    mbedtls_memcpy(p, buf, buflen);
 
     csr->raw.p = p;
     csr->raw.len = len;
@@ -284,6 +448,10 @@ int mbedtls_x509_csr_parse_der(mbedtls_x509_csr *csr,
                                  MBEDTLS_ERR_ASN1_LENGTH_MISMATCH);
     }
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("mbedtls_x509_csr_parse_der - sequence\n");
+    #endif
+
     /*
      *  CertificationRequestInfo ::= SEQUENCE {
      */
@@ -298,6 +466,10 @@ int mbedtls_x509_csr_parse_der(mbedtls_x509_csr *csr,
     end = p + len;
     csr->cri.len = end - csr->cri.p;
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("mbedtls_x509_csr_parse_der - info\n");
+    #endif
+
     /*
      *  Version  ::=  INTEGER {  v1(0) }
      */
@@ -313,6 +485,10 @@ int mbedtls_x509_csr_parse_der(mbedtls_x509_csr *csr,
 
     csr->version++;
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("mbedtls_x509_csr_parse_der - version\n");
+    #endif
+
     /*
      *  subject               Name
      */
@@ -331,6 +507,10 @@ int mbedtls_x509_csr_parse_der(mbedtls_x509_csr *csr,
 
     csr->subject_raw.len = p - csr->subject_raw.p;
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("mbedtls_x509_csr_parse_der - subject\n");
+    #endif
+
     /*
      *  subjectPKInfo SubjectPublicKeyInfo
      */
@@ -339,6 +519,10 @@ int mbedtls_x509_csr_parse_der(mbedtls_x509_csr *csr,
         return ret;
     }
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("mbedtls_x509_csr_parse_der - pk \n");
+    #endif
+
     /*
      *  attributes    [0] Attributes
      *
@@ -365,6 +549,10 @@ int mbedtls_x509_csr_parse_der(mbedtls_x509_csr *csr,
 
     end = csr->raw.p + csr->raw.len;
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("mbedtls_x509_csr_parse_der - attributes\n");
+    #endif
+
     /*
      *  signatureAlgorithm   AlgorithmIdentifier,
      *  signature            BIT STRING
@@ -386,12 +574,20 @@ int mbedtls_x509_csr_parse_der(mbedtls_x509_csr *csr,
         return ret;
     }
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("mbedtls_x509_csr_parse_der - signature\n");
+    #endif
+
     if (p != end) {
         mbedtls_x509_csr_free(csr);
         return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_FORMAT,
                                  MBEDTLS_ERR_ASN1_LENGTH_MISMATCH);
     }
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("mbedtls_x509_csr_parse_der - success\n");
+    #endif
+
     return 0;
 }
 
@@ -556,7 +752,7 @@ int mbedtls_x509_csr_info(char *buf, size_t size, const char *prefix,
  */
 void mbedtls_x509_csr_init(mbedtls_x509_csr *csr)
 {
-    memset(csr, 0, sizeof(mbedtls_x509_csr));
+    mbedtls_memset(csr, 0, sizeof(mbedtls_x509_csr));
 }
 
 /*
@@ -574,12 +770,19 @@ void mbedtls_x509_csr_free(mbedtls_x509_csr *csr)
     mbedtls_free(csr->sig_opts);
 #endif
 
+    mbedtls_x509_crt_free(&(csr->cert_chain));
+    mbedtls_free(csr->attestation_proof.p);
+    mbedtls_free(csr->nonce.p);
+
     mbedtls_asn1_free_named_data_list_shallow(csr->subject.next);
     mbedtls_asn1_sequence_free(csr->subject_alt_names.next);
 
     if (csr->raw.p != NULL) {
         mbedtls_platform_zeroize(csr->raw.p, csr->raw.len);
         mbedtls_free(csr->raw.p);
+        #if MBEDTLS_DEBUG_PRINTS
+        mbedtls_printf("mbedtls_x509_csr_free - free: %lu\n", csr->raw.len);
+        #endif
     }
 
     mbedtls_platform_zeroize(csr, sizeof(mbedtls_x509_csr));
diff --git a/library/x509write_crt.c b/library/x509write_crt.c
index 70d7e93db..bbeccf1d0 100644
--- a/library/x509write_crt.c
+++ b/library/x509write_crt.c
@@ -412,6 +412,9 @@ static int x509_write_time(unsigned char **p, unsigned char *start,
                                                          MBEDTLS_ASN1_GENERALIZED_TIME));
     }
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("x509_write_time - len = %d\n", len);
+    #endif
     return (int) len;
 }
 
@@ -420,43 +423,37 @@ int mbedtls_x509write_crt_der(mbedtls_x509write_cert *ctx,
                               int (*f_rng)(void *, unsigned char *, size_t),
                               void *p_rng)
 {
+    //, unsigned char* test, int *l_topass){
     int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
-    const char *sig_oid;
+    const char *sig_oid = NULL;
     size_t sig_oid_len = 0;
     unsigned char *c, *c2;
-    unsigned char sig[MBEDTLS_PK_SIGNATURE_MAX_SIZE];
-    size_t hash_length = 0;
-    unsigned char hash[MBEDTLS_HASH_MAX_SIZE];
-#if defined(MBEDTLS_USE_PSA_CRYPTO)
-    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
-    psa_algorithm_t psa_algorithm;
-#endif /* MBEDTLS_USE_PSA_CRYPTO */
+    unsigned char sig[64];
+    // size_t hash_length = 0;
+    unsigned char hash[64];
 
     size_t sub_len = 0, pub_len = 0, sig_and_oid_len = 0, sig_len;
     size_t len = 0;
     mbedtls_pk_type_t pk_alg;
 
+    sha3_ctx_t hash_ctx;
+
     /*
      * Prepare data to be signed at the end of the target buffer
      */
-    c = buf + size;
-
-    /* Signature algorithm needed in TBS, and later for actual signature */
-
-    /* There's no direct way of extracting a signature algorithm
-     * (represented as an element of mbedtls_pk_type_t) from a PK instance. */
-    if (mbedtls_pk_can_do(ctx->issuer_key, MBEDTLS_PK_RSA)) {
-        pk_alg = MBEDTLS_PK_RSA;
-    } else if (mbedtls_pk_can_do(ctx->issuer_key, MBEDTLS_PK_ECDSA)) {
-        pk_alg = MBEDTLS_PK_ECDSA;
-    } else {
-        return MBEDTLS_ERR_X509_INVALID_ALG;
-    }
 
-    if ((ret = mbedtls_oid_get_oid_by_sig_alg(pk_alg, ctx->md_alg,
-                                              &sig_oid, &sig_oid_len)) != 0) {
-        return ret;
-    }
+    // buf punta alla prima locazione di memoria del buffer,
+    // se gli aggiungo la sua dimensione, ovvero size
+    // il risultato sarà un puntatore alla fine del buffer, ovvero c
+    c = buf + size;
+    pk_alg = MBEDTLS_PK_ED25519;
+    //    id-Ed25519   OBJECT IDENTIFIER ::= { 1 3 101 112 }
+    mbedtls_oid_get_oid_by_sig_alg(pk_alg, ctx->md_alg, &sig_oid, &sig_oid_len);
+    #if MBEDTLS_DEBUG_PRINTS
+    print_hex_string("sig_oid", (unsigned char*) sig_oid, sig_oid_len);
+    #endif
+    // sig_oid = "{0x2B, 0x65, 0x70}";
+    // sig_oid_len = 3;
 
     /*
      *  Extensions  ::=  SEQUENCE SIZE (1..MAX) OF Extension
@@ -479,6 +476,9 @@ int mbedtls_x509write_crt_der(mbedtls_x509write_cert *ctx,
                                                     MBEDTLS_ASN1_CONSTRUCTED | 3));
     }
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("len - extensions: %d\n", len);
+    #endif
     /*
      *  SubjectPublicKeyInfo
      */
@@ -488,6 +488,9 @@ int mbedtls_x509write_crt_der(mbedtls_x509write_cert *ctx,
     c -= pub_len;
     len += pub_len;
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("len - subPKInfo: %d\n", len);
+    #endif
     /*
      *  Subject  ::=  Name
      */
@@ -495,6 +498,9 @@ int mbedtls_x509write_crt_der(mbedtls_x509write_cert *ctx,
                          mbedtls_x509_write_names(&c, buf,
                                                   ctx->subject));
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("len - subject: %d\n", len);
+    #endif
     /*
      *  Validity ::= SEQUENCE {
      *       notBefore      Time,
@@ -517,12 +523,18 @@ int mbedtls_x509write_crt_der(mbedtls_x509write_cert *ctx,
                                                 MBEDTLS_ASN1_CONSTRUCTED |
                                                 MBEDTLS_ASN1_SEQUENCE));
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("len - validity: %d\n", len);
+    #endif
     /*
      *  Issuer  ::=  Name
      */
     MBEDTLS_ASN1_CHK_ADD(len, mbedtls_x509_write_names(&c, buf,
                                                        ctx->issuer));
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("len - issuer: %d\n", len);
+    #endif
     /*
      *  Signature   ::=  AlgorithmIdentifier
      */
@@ -530,6 +542,9 @@ int mbedtls_x509write_crt_der(mbedtls_x509write_cert *ctx,
                          mbedtls_asn1_write_algorithm_identifier(&c, buf,
                                                                  sig_oid, strlen(sig_oid), 0));
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("len - aId: %d\n", len);
+    #endif
     /*
      *  Serial   ::=  INTEGER
      *
@@ -556,6 +571,9 @@ int mbedtls_x509write_crt_der(mbedtls_x509write_cert *ctx,
     MBEDTLS_ASN1_CHK_ADD(len, mbedtls_asn1_write_tag(&c, buf,
                                                      MBEDTLS_ASN1_INTEGER));
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("len - serial: %d\n", len);
+    #endif
     /*
      *  Version  ::=  INTEGER  {  v1(0), v2(1), v3(2)  }
      */
@@ -579,49 +597,61 @@ int mbedtls_x509write_crt_der(mbedtls_x509write_cert *ctx,
                          mbedtls_asn1_write_tag(&c, buf, MBEDTLS_ASN1_CONSTRUCTED |
                                                 MBEDTLS_ASN1_SEQUENCE));
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("len - version: %d\n", len);
+    #endif
+    /* *
+     *
+     * Fase di firma, svolta con le funzioni già presenti in keystone
+     *
+     *  sha3_init(&hash_ctx, 64);
+        sha3_update(&hash_ctx, c, len);
+        sha3_final(hash, &hash_ctx);
+     *
+     * */
     /*
-     * Make signature
-     */
-
-    /* Compute hash of CRT. */
-#if defined(MBEDTLS_USE_PSA_CRYPTO)
-    psa_algorithm = mbedtls_hash_info_psa_from_md(ctx->md_alg);
-
-    status = psa_hash_compute(psa_algorithm,
-                              c,
-                              len,
-                              hash,
-                              sizeof(hash),
-                              &hash_length);
-    if (status != PSA_SUCCESS) {
-        return MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
-    }
-#else
-    if ((ret = mbedtls_md(mbedtls_md_info_from_type(ctx->md_alg), c,
-                          len, hash)) != 0) {
-        return ret;
-    }
-#endif /* MBEDTLS_USE_PSA_CRYPTO */
-
+    for(int i = 0; i < len; i ++)
+      test[i] = c[i];
+    *l_topass = len;
+*/
+    sha3_init(&hash_ctx, 64);
+    sha3_update(&hash_ctx, c, len);
+    sha3_final(hash, &hash_ctx);
+
+    // for(int i = 0; i < len; i ++)
+    //  test[i] = c[i];
+    // mbedtls_memcpy(test, hash, 64);
 
+    /*
     if ((ret = mbedtls_pk_sign(ctx->issuer_key, ctx->md_alg,
                                hash, hash_length, sig, sizeof(sig), &sig_len,
                                f_rng, p_rng)) != 0) {
         return ret;
     }
+    */
 
+    mbedtls_ed25519_context *ed25519 = mbedtls_pk_ed25519(*(ctx->issuer_key));
+    if(ed25519->no_priv_key == 0) {
+        ed25519_sign(sig, hash, 64, ed25519->pub_key, ed25519->priv_key);
+        sig_len = 64;
+    } else {
+        crypto_interface(2, (void*) hash, MBEDTLS_HASH_MAX_SIZE, sig, &sig_len, ed25519->pub_key);
+    }
+    
     /* Move CRT to the front of the buffer to have space
      * for the signature. */
-    memmove(buf, c, len);
+    mbedtls_memmove(buf, c, len);
     c = buf + len;
 
     /* Add signature at the end of the buffer,
      * making sure that it doesn't underflow
      * into the CRT buffer. */
     c2 = buf + size;
-    MBEDTLS_ASN1_CHK_ADD(sig_and_oid_len, mbedtls_x509_write_sig(&c2, c,
-                                                                 sig_oid, sig_oid_len, sig,
-                                                                 sig_len));
+    if (sig_oid != NULL) {
+        MBEDTLS_ASN1_CHK_ADD(sig_and_oid_len, mbedtls_x509_write_sig(&c2, c,
+                                                                     sig_oid, sig_oid_len, sig,
+                                                                     sig_len));
+    }
 
     /*
      * Memory layout after this step:
@@ -632,7 +662,7 @@ int mbedtls_x509write_crt_der(mbedtls_x509write_cert *ctx,
 
     /* Move raw CRT to just before the signature. */
     c = c2 - len;
-    memmove(c, buf, len);
+    mbedtls_memmove(c, buf, len);
 
     len += sig_and_oid_len;
     MBEDTLS_ASN1_CHK_ADD(len, mbedtls_asn1_write_len(&c, buf, len));
@@ -640,6 +670,9 @@ int mbedtls_x509write_crt_der(mbedtls_x509write_cert *ctx,
                                                      MBEDTLS_ASN1_CONSTRUCTED |
                                                      MBEDTLS_ASN1_SEQUENCE));
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("len - signature: %d\n", len);
+    #endif
     return (int) len;
 }
 
diff --git a/library/x509write_csr.c b/library/x509write_csr.c
index deb66174b..02c1beae2 100644
--- a/library/x509write_csr.c
+++ b/library/x509write_csr.c
@@ -48,9 +48,11 @@
 
 #include "mbedtls/platform.h"
 
+#include "keystone_ext.h"
+
 void mbedtls_x509write_csr_init(mbedtls_x509write_csr *ctx)
 {
-    memset(ctx, 0, sizeof(mbedtls_x509write_csr));
+    mbedtls_memset(ctx, 0, sizeof(mbedtls_x509write_csr));
 }
 
 void mbedtls_x509write_csr_free(mbedtls_x509write_csr *ctx)
@@ -124,6 +126,9 @@ int mbedtls_x509write_csr_set_subject_alternative_name(mbedtls_x509write_csr *ct
     if (buf == NULL) {
         return MBEDTLS_ERR_ASN1_ALLOC_FAILED;
     }
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("mbedtls_x509write_csr_set_subject_alternative_name - calloc: %lu\n", buflen);
+    #endif
 
     mbedtls_platform_zeroize(buf, buflen);
     p = buf + buflen;
@@ -182,6 +187,9 @@ int mbedtls_x509write_csr_set_subject_alternative_name(mbedtls_x509write_csr *ct
 
 cleanup:
     mbedtls_free(buf);
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("mbedtls_x509write_csr_set_subject_alternative_name - free: %lu\n", buflen);
+    #endif
     return ret;
 }
 
@@ -237,7 +245,7 @@ static int x509write_csr_der_internal(mbedtls_x509write_csr *ctx,
                                       size_t size,
                                       unsigned char *sig, size_t sig_size,
                                       int (*f_rng)(void *, unsigned char *, size_t),
-                                      void *p_rng)
+                                      void *p_rng) // new_impl
 {
     int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
     const char *sig_oid;
@@ -315,31 +323,22 @@ static int x509write_csr_der_internal(mbedtls_x509write_csr *ctx,
      * Sign the written CSR data into the sig buffer
      * Note: hash errors can happen only after an internal error
      */
-#if defined(MBEDTLS_USE_PSA_CRYPTO)
-    if (psa_hash_compute(hash_alg,
-                         c,
-                         len,
-                         hash,
-                         sizeof(hash),
-                         &hash_len) != PSA_SUCCESS) {
-        return MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
-    }
-#else /* MBEDTLS_USE_PSA_CRYPTO */
     ret = mbedtls_md(mbedtls_md_info_from_type(ctx->md_alg), c, len, hash);
+    #if MBEDTLS_DEBUG_PRINTS
+    print_hex_string("x509write_csr_der_internal - hash", hash, MBEDTLS_HASH_MAX_SIZE);
+    #endif
     if (ret != 0) {
         return ret;
     }
-#endif
-    if ((ret = mbedtls_pk_sign(ctx->key, ctx->md_alg, hash, 0,
+
+    if ((ret = mbedtls_pk_sign(ctx->key, ctx->md_alg, hash, MBEDTLS_HASH_MAX_SIZE,
                                sig, sig_size, &sig_len,
                                f_rng, p_rng)) != 0) {
         return ret;
     }
 
-    if (mbedtls_pk_can_do(ctx->key, MBEDTLS_PK_RSA)) {
-        pk_alg = MBEDTLS_PK_RSA;
-    } else if (mbedtls_pk_can_do(ctx->key, MBEDTLS_PK_ECDSA)) {
-        pk_alg = MBEDTLS_PK_ECDSA;
+    if (mbedtls_pk_can_do(ctx->key, MBEDTLS_PK_ED25519)) {
+        pk_alg = MBEDTLS_PK_ED25519;
     } else {
         return MBEDTLS_ERR_X509_INVALID_ALG;
     }
@@ -353,7 +352,7 @@ static int x509write_csr_der_internal(mbedtls_x509write_csr *ctx,
      * Move the written CSR data to the start of buf to create space for
      * writing the signature into buf.
      */
-    memmove(buf, c, len);
+    mbedtls_memmove(buf, c, len);
 
     /*
      * Write sig and its OID into buf backwards from the end of buf.
@@ -370,7 +369,7 @@ static int x509write_csr_der_internal(mbedtls_x509write_csr *ctx,
      * CSR data to the start of the signature.
      */
     c2 -= len;
-    memmove(c2, buf, len);
+    mbedtls_memmove(c2, buf, len);
 
     /* ASN encode the total size and tag the CSR data with it. */
     len += sig_and_oid_len;
@@ -381,7 +380,7 @@ static int x509write_csr_der_internal(mbedtls_x509write_csr *ctx,
                              MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE));
 
     /* Zero the unused bytes at the start of buf */
-    memset(buf, 0, c2 - buf);
+    mbedtls_memset(buf, 0, c2 - buf);
 
     return (int) len;
 }
@@ -398,12 +397,20 @@ int mbedtls_x509write_csr_der(mbedtls_x509write_csr *ctx, unsigned char *buf,
         return MBEDTLS_ERR_X509_ALLOC_FAILED;
     }
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("mbedtls_x509write_csr_der - calloc: %lu\n", MBEDTLS_PK_SIGNATURE_MAX_SIZE);
+    #endif
+
     ret = x509write_csr_der_internal(ctx, buf, size,
                                      sig, MBEDTLS_PK_SIGNATURE_MAX_SIZE,
                                      f_rng, p_rng);
 
     mbedtls_free(sig);
 
+    #if MBEDTLS_DEBUG_PRINTS
+    mbedtls_printf("mbedtls_x509write_csr_der - free: %lu\n", MBEDTLS_PK_SIGNATURE_MAX_SIZE);
+    #endif
+
     return ret;
 }
 
@@ -433,4 +440,102 @@ int mbedtls_x509write_csr_pem(mbedtls_x509write_csr *ctx, unsigned char *buf, si
 }
 #endif /* MBEDTLS_PEM_WRITE_C */
 
+// custom new_impl: function to write a single DICE certificate
+static int write_certs(unsigned char **p, const unsigned char *start, unsigned char *cert, int size){
+    size_t len = 0;
+    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
+    MBEDTLS_ASN1_CHK_ADD(len, mbedtls_asn1_write_raw_buffer(p, start,
+                                                            cert, size));
+
+    MBEDTLS_ASN1_CHK_ADD(len, mbedtls_asn1_write_len(p, start,
+                                                        size));
+    MBEDTLS_ASN1_CHK_ADD(len, mbedtls_asn1_write_tag(p, start,
+                                                     MBEDTLS_ASN1_OCTET_STRING));
+    return (int) len;
+}
+
+// custom new_impl: function to write DICE certificates
+int mbedtls_x509write_csr_set_dice_certs(mbedtls_x509write_csr *ctx, unsigned char *certs[], int *sizes) {
+    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
+    size_t len = 0;
+    unsigned char buf[1024] = {0};
+
+    unsigned char *c = buf + 1024;
+
+    MBEDTLS_ASN1_CHK_ADD(len, write_certs(&c, buf, certs[2], sizes[2]));
+    MBEDTLS_ASN1_CHK_ADD(len, write_certs(&c, buf, certs[1], sizes[1]));
+    MBEDTLS_ASN1_CHK_ADD(len, write_certs(&c, buf, certs[0], sizes[0]));
+
+    MBEDTLS_ASN1_CHK_ADD(len, mbedtls_asn1_write_len(&c, buf, len));
+    MBEDTLS_ASN1_CHK_ADD(len, mbedtls_asn1_write_tag(&c, buf, MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE));
+
+    unsigned char *parsed_certs = buf;
+    int dif_certs = 1024-len;
+    parsed_certs += dif_certs;
+
+    #if MBEDTLS_DEBUG_PRINTS
+    print_hex_string("asn1 cert chain", parsed_certs, len);
+    #endif
+    
+    ret = mbedtls_x509write_csr_set_extension(ctx, MBEDTLS_OID_DICE_CERTS, MBEDTLS_OID_SIZE(MBEDTLS_OID_DICE_CERTS),
+        0, parsed_certs, len);
+
+    return ret;
+}
+
+// custom new_impl: function to write nonce
+int mbedtls_x509write_csr_set_nonce(mbedtls_x509write_csr *ctx, unsigned char *nonce) {
+    unsigned char buf[NONCE_LEN + 2] = { 0 };
+    unsigned char *c;
+    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
+    size_t len = 0;
+    
+    c = buf + NONCE_LEN + 2;
+
+    MBEDTLS_ASN1_CHK_ADD(len, mbedtls_asn1_write_raw_buffer(&c, buf, nonce, NONCE_LEN));
+    MBEDTLS_ASN1_CHK_ADD(len, mbedtls_asn1_write_len(&c, buf, len));
+    MBEDTLS_ASN1_CHK_ADD(len, mbedtls_asn1_write_tag(&c, buf, MBEDTLS_ASN1_OCTET_STRING));
+
+    if (len != (NONCE_LEN + 2)) {
+        return ret;
+    }
+
+    #if MBEDTLS_DEBUG_PRINTS
+    print_hex_string("asn1 nonce", c, NONCE_LEN+2);
+    #endif
+
+    ret = mbedtls_x509write_csr_set_extension(ctx, MBEDTLS_OID_NONCE, MBEDTLS_OID_SIZE(MBEDTLS_OID_NONCE),
+        0, c, (size_t) len);
+
+    return ret;
+}
+
+// custom new_impl: function to write attestation evidence
+int mbedtls_x509write_csr_set_attestation_proof(mbedtls_x509write_csr *ctx, unsigned char *attest_proof) {
+    unsigned char buf[ATTESTATION_PROOF_LEN + 2] = { 0 };
+    unsigned char *c;
+    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
+    size_t len = 0;
+    
+    c = buf + ATTESTATION_PROOF_LEN + 2;
+
+    MBEDTLS_ASN1_CHK_ADD(len, mbedtls_asn1_write_raw_buffer(&c, buf, attest_proof, ATTESTATION_PROOF_LEN));
+    MBEDTLS_ASN1_CHK_ADD(len, mbedtls_asn1_write_len(&c, buf, len));
+    MBEDTLS_ASN1_CHK_ADD(len, mbedtls_asn1_write_tag(&c, buf, MBEDTLS_ASN1_OCTET_STRING));
+
+    if (len != (ATTESTATION_PROOF_LEN + 2)) {
+        return ret;
+    }
+
+    #if MBEDTLS_DEBUG_PRINTS
+    print_hex_string("asn1 attest_proof", c, ATTESTATION_PROOF_LEN+2);
+    #endif
+
+    ret = mbedtls_x509write_csr_set_extension(ctx, MBEDTLS_OID_ATTESTATION_PROOF, MBEDTLS_OID_SIZE(MBEDTLS_OID_ATTESTATION_PROOF),
+        0, c, (size_t) len);
+
+    return ret;
+}
+
+
 #endif /* MBEDTLS_X509_CSR_WRITE_C */
diff --git a/programs/test/udp_proxy.c b/programs/test/udp_proxy.c
index ac527f257..4d631fe04 100644
--- a/programs/test/udp_proxy.c
+++ b/programs/test/udp_proxy.c
@@ -258,7 +258,7 @@ static void get_options(int argc, char *argv[])
             buf = mbedtls_calloc(1, len + 1);
             if (buf == NULL) {
                 mbedtls_printf(" Allocation failure\n");
-                exit(1);
+                mbedtls_exit(1);
             }
             memcpy(buf, q, len + 1);
 
